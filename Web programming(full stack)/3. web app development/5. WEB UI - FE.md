> 부스트 코스 - 웹 프로그래밍(풀스택) 강의를 학습, 정리한 내용입니다. (https://www.boostcourse.org/web316/joinLectures/12943)

# DOM API활용 - FrontEnd
# 목차



# 1) 서비스 개발을 위한 디렉토리 구성
서비스를 개발할 때 JavaScript 코드가 많아지면 어떻게 보관하고 관리해야 하는지 잘 모를 때가 있다.

소스코드상에서도 많아진 JavaScript 코드를 어떻게 표현해야 할지도 고민이고요.

어려운 방법은 아니니 이번에 그것들을 알아보자.

## 학습 목표
웹브라우저 렌더링에 필요한 JavaScript와 CSS파일의 구성방법을 이해한다.
 
## 핵심 개념
* 개발환경 구성
* 브라우저에서 동작가능하도록 JavaScript와 CSS의 소스코드 위치시키기
 
## 1. JavaScript파일 구성
간단한 내용의 JavaScript라면 한 페이지에 모두 표현하는 것도 좋다.

그렇지 않다면 의미에 맞게 구분하는 방법이 더 좋다.

## 2. HTML안에 JavaScript 구성하기
CSS는 head태그 안에 상단에 위치.

JavaScript는 body 태그가 닫히기 전에 소스파일 간 의존성을 이해해서 순서대로 배치.
 
## 생각해보기
여러분들이 자주 가는 웹사이트를 열고, 먼저 Element 패널에서 JavaScript는 위치가 어디 있는지, CSS파일은 어떻게 위치시켰는지 알아봅니다. 
크롬 개발자도구의 소스패널을 열어서 서비스에서 JavaScript 소스 파일들을 찾고 몇 개의 파일로 구성되어 있는지 알아봅니다.
 
## 참고 자료 
> [참고링크](https://stackoverflow.com/questions/2414750/difference-between-domcontentloaded-and-load-events) Difference between DOMContentLoaded and load events 


# 2) DOMContentLoaded 이벤트
로딩 이후에 자바스크립트 동작이 이뤄지는 것이 일반적.

자바스크립트가 실행돼야 할 가장 적절한 타이밍은 언제일까?

## 학습 목표
DOM ContentLoaded 이벤트를 이해한다.
Load와의 차이점을 이해한다.

## 핵심 개념
* DOMContentLoaded

[영상보완]
html중간중간에 script를 추가해도 됩니다. 하지만 해당 DOM이 정의된 HTML코드 뒤에 작성해야지, 그전에 작성하면 해당 DOM node를 찾지 못합니다.
* 아래는 정상적으로 찾아집니다.  
    `<div>a</div><script>document.querySelector("div")</script>`
 
* 하지만 아래는 null입니다.  
    `<script>document.querySelector("div")</script><div>a</div>`

## load와 DOMContentLoaded의 차이 확인
웹사이트에 접속해서 크롬 개발자도구로 이를 확인할 수 있습니다.

크롬 개발자도구의 Network panel을 열어서 하단에 DOMContentLoaded, load를 확인해보세요. 

두 개의 시간이 조금 다릅니다.

DOM Tree 분석이 끝나면 DOMContentLoaded 이벤트가 발생하며, 그 외 모든 자원이 다 받아져서 브라우저에 렌더링(화면 표시)까지 다 끝난 시점에는 Load가 발생합니다.

이를 이해하고, 필요한 시점에 두 개의 이벤트를 사용해서 자바스크립트 실행을 할 수 있습니다. 

보통 DOM tree가 다 만들어지면 DOM APIs를 통해서 DOM에 접근할 수 있기 때문에, 실제로 실무에서는 대부분의 자바스크립트코드는 DOMContentLoaded 이후에 동작하도록 구현합니다.

그 방법이 로딩속도 성능에 유리하다고 생각하기 때문입니다.

## DOMContentLoaded 예제
```js
document.addEventListener("DOMContentLoaded", function() {
  startSomething();
  initFoo();
  initBar();
  var el = document.querySelector("div");
});
```

## 생각해보기
load이벤트 이후에 작업하는 게 좋은 건 어떤 걸까요?

## 참고 자료
> [참고링크](https://stackoverflow.com/questions/2414750/difference-between-domcontentloaded-and-load-events) Difference between DOMContentLoaded and load events


# 3) Event delegation-1
list(어떤 목록)가 여러 개인 UI에 각각 비슷한 이벤트를 걸어서 처리해야 한다면 어떻게 해야 할까요? 

for문으로 addEventListener를 사용해야 할까요?

## 학습 목표
Event delegation을 이해하고, 효율적인 이벤트 등록을 구현할 수 있다.
 
## 핵심 개념
* Event delegation
* Bubbling
* Capturing
 
## 1)
이런 상황에서의 이벤트 등록

아래 화면은 가로로 배치된 책 리스트입니다.

각각 리스트에 클릭을 할 때 어떤 이벤트가 발생해야 한다고 가정합니다.

addEventListener를 사용해서 이벤트 등록을 할 수 있을겁니다.


책 리스트
4개의 예제에는 li 태그가 있습니다.

<ul>
  <li>
    <img src="https://images-na.,,,,,/513hgbYgL._AC_SY400_.jpg" class="product-image" >    </li>
  <li>
    <img src="https://images-n,,,,,/41HoczB2L._AC_SY400_.jpg" class="product-image" >    </li>
  <li>
    <img src="https://images-na.,,,,51AEisFiL._AC_SY400_.jpg" class="product-image" >  </li>
 <li>
    <img src="https://images-na,,,,/51JVpV3ZL._AC_SY400_.jpg" class="product-image" >
 </li>
</ul>
li 각각에 addEventListener를 통해 이벤트를 등록합니다. 

이 코드는 잘 동작합니다.

var log = document.querySelector(".log");
var lists = document.querySelectorAll("ul > li");

for(var i=0,len=lists.length; i < len; i++) {
  lists[i].addEventListener("click", function(evt) {
     log.innerHTML = "clicked" + evt.currentTarget.firstChild.src;
  });
}
브라우저는 4개의 이벤트 리스너를 기억하고 있습니다.

그런데 list가 훨씬 더 많다면 브라우저는 기억해야 할 이벤트 리스너도 그만큼 많아집니다.

비효율적이죠.  

문제는 한가지 더 있습니다. 만약 list가 한 개 더 동적으로 추가된다면 어떻게 될까요?

네, 추가된 엘리먼트에 역시 addEventListener를 해줘야 합니다.

이것도 꽤 불편한 일 같네요.

target 정보가 우리를 돕습니다.

자, 이번에는 ul 태그에만 이벤트를 새롭게 등록합니다. 

ul.addEventListener("click",function(evt) {
    console.log(evt.currentTarget, evt.target);
});
이럴 경우 li안에 이미지를 클릭하면 위 결과는 무엇일까요?

만약 ul > li > img 태그를 클릭했다면 어떤 결과가 나올까요?

그 전에 이벤트는 실행은 될까요?

정답은 '네' 입니다. 

 li 나 img 태그는 ul 태그에 속하기도 합니다.

따라서 UL에 등록한 이벤트 리스너도 실행이 됩니다. 

이것은 이벤트 버블링이라고 합니다.

클릭한 지점이 하위엘리먼트라고 하여도, 그것을 감싸고 있는 상위 엘리먼트까지 올라가면서 이벤트리스너가 있는지 찾는 과정입니다. 

만약 img, li, ul에 각각 이벤트를 등록했었다면, 3개의 이벤트 리스너가 실행했을 겁니다. 

아래 이미지는 하위엘리먼트는 3번부터 이벤트가 발생하고 2,1 순으로 이벤트가 발생했습니다.

비슷하게 Capturing이라는 것도 있습니다. 반대로 이벤트가 발생하는 것인데요.

기본적으로는 Bubbling 순서로 이벤트가 발생합니다.

따라서 Bubbling을 잘 기억해두는 게 좋습니다.

Capturing 단계에서 이벤트 발생을 시키고 싶다면 addEventListener 메서드의 3번째 인자에 값을 true로 주면 됩니다. 


Event Bubbling
출처 https://www.grapecity.com/en/blogs/html-and-wijmo-events/


## 2)
우리는 img나 li를 클릭해도 UL에도 이벤트가 발생하고, 이벤트 리스너 실행된다는 것을 알게 됐습니다.

img를 클릭하면 아래 결과는 무엇이 나올까요?

ul 그리고 img 태그가 나옵니다. 

ul.addEventListener("click",function(evt) {
    console.log(evt.currentTarget.tagName, evt.target.tagName);
});
네 target 정보는 실제 클릭 된 하위 엘리먼트를 알려줍니다!

이 점을 이용해서 src를 추출할 수 있지 않을까요? 

이제 addEventListener 메서드를 한 번만 쓰면서 우리는 모든 list의 image 정보를 확인할 수 있습니다.

더구나 list 태그가 하나 더 추가된다고 하여도 문제없이 동작합니다.

var ul = document.querySelector("ul");
ul.addEventListener("click",function(evt) {
    if(evt.target.tagName === "IMG") {
      log.innerHTML = "clicked" + evt.target.src;
    }
});
그런데 작은 문제가 하나 더 있는 거 같네요.

예제를 보면, 이미지 태그는 padding 값이 있어서, img태그와 li 태그 사이에 공백이 존재합니다.

이 부분(공백)을 클릭하면 tagName이 LI라서 위에서 구현한 조건문으로 들어가지 않았기 때문입니다.

이 부분(공백)을 클릭해도 이미지 url을 출력할 수 있으려면 어떻게 해야할까요?

var ul = document.querySelector("ul");
ul.addEventListener("click",function(evt) {
  debugger;
    if(evt.target.tagName === "IMG") {
      log.innerHTML = "clicked" + evt.target.src;
    } else if (evt.target.tagName === "LI") {
      log.innerHTML = "clicked" + evt.target.firstChild.src;
    }
});
전체코드는 여기서 확인 하세요.

실습코드 바로가기

## 생각해보기
이벤트 버블링과 캡쳐링의 차이점은 무엇일까요?

## 참고 자료
> [참고링크](https://javascript.info/bubbling-and-capturing) Bubbling and capturing
