- [The secret life of programming](#the-secret-life-of-programming)
  * [**1. 시간 표현과 상태 기억**](#--1---------------)
    + [**1-1. 발진자**](#--1-1------)
    + [**1-2. 클록**](#--1-2-----)
    + [**1-3. 래치**](#--1-3-----)
    + [**1-4. 게이트가 있는 래치**](#--1-4-------------)
    + [**1-5. 플립플롭**](#--1-5-------)
    + [**1-6. 카운터**](#--1-6------)
    + [**1-7. 레지스터**](#--1-7-------)
  * [**2. 메모리 조직과 주소지정**](#--2---------------)
    + [**2-1. 임의 접근 메모리**](#--2-1------------)
    + [**2-2. 읽기 전용 메모리**](#--2-2------------)
  * [**3. 블록장치**](#--3-------)
  * [**4. 플래시 메모리와 SSD**](#--4----------ssd--)
  * [**5. 오류 감지와 정정**](#--5------------)
  * [**6. 하드웨어와 소프트웨어 비교**](#--6-----------------)
  * [**chapter 3 정리**](#--chapter-3-----)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


# The secret life of programming 
 **Chapter 3. Main point of memory and disk : Sequential logic**

- How the computer remembers the beat
    - The circuit that creates time
    - The circuit to remember the past


*** 
***
## **1. 시간 표현과 상태 기억**
    시간을 어떻게 재는가 : 주기함수
        * 자전
        * 진자 - 괘종시계
    컴퓨터에서 시간을 재기 위해 주기적인 전기 신호가 필요하다.
    
**메모리(RAM)을 만드는 방법 (1-1 ~ 1-7)**

### **1-1. 발진자**
주기적인 전기신호로 시간을 잰다.
- feedback(피드백, 되먹임) : 출력을 입력에 연결 
    - 예시) 마이크와 스피커를 가까이
    - 진동한다(발진한다. 발진자.)
- 피에조 전기(압전) 효과 : 전극을 크리스털(결정)에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어 낸다 그리고 전극에 전기를 가하면 크리스털이 구부러진다.
    - 가장 좋은 크리스털 고체 물질 : 석영
- 크리스털 발진자 : 전자적인 단극쌍투 스위치 사용. 크리스털에 전기를 가해서 다시 전기를 얻어낸다.

### **1-2. 클록**
시간을 표현하는 근원
- 저수준 : 전자적/기계적 부품에 가까우면
- 고수준 : 사용자/프로그래머에 가까우면
    - 트랜지스터 < 게이트 < CPU
- 발진자는 컴퓨터에 clock(시간을 셀 수 있게 해주는 신호)을 제공 
- 비닝 : 부품 별로 전파 지연시간에 따라 분류
- 오버클로킹 : (중간정도의 빈에 위치하는)부품이 고장이 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박

### **1-3. 래치**
정보를 1비트 기억할 방법
- OR 게이트의 출력을 입력에 묶는 방식의 피드백을 사용하면 정보를 기억할 수 있다.
    - OR 게이트 래치 : 과거상태 기억 회로
    - AND-OR 게이트 래치 : 피드백을 끊고 회로를 재설정 가능
        - reset 바
        - 액티브 하이, 액티브 로우
    - S-R(set-reset) 래치 : 액티브 로우 입력을 받고 보수 출력을 제공
        - 단점 : 전력 ⬆, 복잡, 비용 ⬆, s-r 모두 참 - 전파지연시간에 따라 출력이 달라짐
        - 장점 : 설계가 대칭적 - set과 reset신호의 지연시간이 거의 비슷
 
### **1-4. 게이트가 있는 래치**
어느 시점에 무언가를 기억한다는 것
- D : 1비트 입력
- 게이트가 있는 D 래치
- 타이밍 다이어그램

### **1-5. 플립플롭**
시간에 대한 판정기준(안정성)
- 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화 - 에지
- edge(에지) : 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것. (시간에 대한 판정 기준)
- 플립플롭(flip-flop) : 에지에 의해 데이터 변화가 촉발되는 래치
- D 플립플롭 : 양의 에지에 의해 변화가 촉발되는(논리 수준 0에서 1로 바뀔 때 출력이 바뀐다) 플립플롭
    - 7474 : 진공관을 사용한 최초의 전자적 D 플립플롭
        - setup time, hold time

### **1-6. 카운터**
시간을 세는 방법
- 카운터 : 플립플롭을 응용한 회로. 1,2,3 순서대로 수를 센다.
    - 디지털시계 - 발진자에서 나온 시간을 세고 그 값을 디코더에 공급해 숫자를 표시하는 디스플레이를 제어하는 방식으로 만든다.
- 3비트 리플 카운터
    - 리플카운터 : 물에서 물결이 퍼져나가듯이 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나간다. 
    - 비동기 카운터 : 각 비트의 상태가 다른 비트의 상태변화에 약간의 시차를 두고 바뀐다.
  
### **1-7. 레지스터**
더 많은 정보를 저장하는 방법
- 레지스터 : 클록을 공유하는 여러 D플립플롭을 한 패키지에 넣은 것


---
## **2. 메모리 조직과 주소지정**
    훨씬 더 많은 정보를 저장하는 방법
    * 여러 개의 레지스터 사용하기
      * 각각 번호(주소) 부여 - 디코더
      * 지정한 주소 출력 선택 방법 - 셀렉터
      * 여러 출력을 한 출력으로 - 트라이스테이트
      
      => 메모리 컴포넌트(메모리 회로) => 단순화한 메모리 칩(주소, 데이터 버스(비트 대량이동수단) 사용)
    
    * 열과 행 어드레싱(메모리 내부 위치 지정)
    * 주소 레지스터를 사용하는 메모리 (멀티플렉싱)

    * 오늘날의 메모리 칩 : 행 주소를 먼저 지정, 열 주소만 변화시켜 좀더 빨리 처리
    * 메모리 칩의 크기 : 깊이 × 너비
      ex) 256 × 8 chip , 64Mib × 1 chip

### **2-1. 임의 접근 메모리**
RAM (random access memory) : 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.
1. 휘발성 메모리 - RAM(SRAM, DRAM)
   * SRAM (static RAM) 
     * 각 비트에 트랜지스터가 6개 들어간다. 
     * 비싸지만 아주 빠르다
   * DRAM (dynamic RAM)
     * 커패시터에 전자를 담고 트랜지스터를 1개만 사용한다.
     * 가끔 갱신이 필요하다. 
     * 빛이 버킷에 비치면 버킷이 새는 속도가 더 빨라진다 - 디지털 카메라에 활용
     * 집적도가 높다 - 큰 메모리 칩
2. 비휘발성 메모리 
   * core 메모리
     * 비트를 토러스 모양의 쇳조각에 저장
     * 가로세로 선이 통과하는 격자에 코어가 배열된 평면으로 배열
     * 코어를 읽기 위한 감지선 필요
     * 3차원 메모리(평면을 모아 brick을 만듦)
3. MRAM : 코어 메모리와 RAM의 장점을 합친 실용적인 자기 저항성 메모리 (개발 중)

### **2-2. 읽기 전용 메모리**
ROM (read-only memory) : 한 번만 쓸 수 있는 메모리. 한 번 쓰고 여러 번 읽는다. - 전자레인지

* 홀러리스 카드(IBM 카드) : 비트들을 종이에 구멍으로 뚫어 표시
  * 초기 - 스위치를 사용해 비트를 읽음(광감지기)
* 천공 종이 테이프 
* 코어 로프 메모리 - 아폴로호 비행 제어 컴퓨터(바느질)
* 마스크 프로그래머블 ROM(Mask ROM) : 재프로그래밍 불가(읽기 전용), 임의 접근 가능(모든 가전제품)
* PROM (programmable ROM) : 생산 후 사용자가 한 번만 기록할 수 있는 ROM (OTP라고도 함)
* EPROM (erasable PROM) : 자외선을 이용하여 기억된 내용을 지우고 다시 기록할 수 있는 ROM. (ROM writer, ROM eraser)
* EEPROM (electrically EPROM) : 전기로 지울 수 있는 EPROM. 플래시 메모리에 점점 밀려남. 일부 가전제품에서 사용.


---
## **3. 블록장치**
    디스크 드라이브 : 자화된 판에 비트 저장. 
                     디스크 헤드가 손. 
                     느리지만 대량 저장.
                     블록(섹터) 단위로 주소를 지정해 읽는다. 
                     최근 디스크들은 방사상 영역으로 구분해 바깥쪽 트랙에 공간이 남는 낭비를 해결.
                     회전 지연 시간이 중요.
  * 종류
    1. 하드 드라이브
    2. 플로피 디스크
    3. 자기 드럼 저장 장치   
    5. 광학 디스크
  * 자기 테이프 : 자화시킨 테이프를 감은 릴을 사용하는 비휘발성 저장장치. 디스크 드라이브보다 느리지만 기업용, 정부용으로 대규모 저장과 백업에 쓰인다. (용량 대비 비용 저렴, 신뢰성, 안정성, 수명)
    * LTO 카트리지(손바닥만한 크기)
      * LTO-7 무압축 6TB, 압축 15TB
      * LTO-12 192, 480TB


---
## **4. 플래시 메모리와 SSD**
    * 플래시 메모리 
      - EEPROM유형의 매체
      - mp3, 디지털 카메라, 스마트폰, 게임, usb드라이브      
      - EEPROM보다 더 빨리 지우고 더 저렴
      - 읽을 때는 임의 접근, 쓸 때는 블록 접근
    * SSD (solid-state drive) 
      - 반도체를 이용하여 정보를 저장하는 장치
        1. RAM과 비슷한 기술을 이용한 초기 SSD
        2. 플래시 기반 SSD
        3. 엔터프라이즈 플래시 드라이브
---
## **5. 오류 감지와 정정**
    원본 데이터의 완벽한 복사본을 저장하지 않고도 데이터 오류가 발생했는지 알 수 있다. 
    * parity : 단 1비트만 데이터가 잘못된 경우 감지 (짝수 패리티, 홀수 패리티)
    * hamming code
    * ECC memory chip
    * checksum
    * CRC


---
## **6. 하드웨어와 소프트웨어 비교**
    소프트웨어는 설계에 들어가는 시간이라는 비용을 제외한 어떤 추가비용도 들지 않기 때문에 
    소프트웨어가 하드웨어보다 훨씬 더 만들기 쉽다는 점을 빼고는
    차이가 거의 없다.  

* 펌웨어 : ROM에 담긴 소프트웨어 > 플래시 메모리상, RAM에도 존재
     ><**wikipedia**> 
펌웨어(firmware)는 컴퓨팅과 공학 분야에서 특정 하드웨어 장치에 포함된 소프트웨어로, 소프트웨어를 읽어 실행하거나, 수정하는 것도 가능한 장치를 뜻한다. 하드웨어의 제어(low-level control)와 구동을 담당하는 일종의 운영체제이다. 펌웨어는 ROM이나 PROM에 저장되며, 하드웨어보다는 교환하기가 쉽지만, 소프트웨어보다는 어렵다.
* EDA(전자 설계 자동화) - 칩설계 = 소프트웨어 설계
* full custom
* gate array
* FPGA(field-programmable gate array) : 플래시 메모리에 해당하는 논리 칩
   
    => 소프트웨어 to 하드웨어 변환 사례


***
## **chapter 3 정리**
* 컴퓨터가 시간을 어떻게 인식하게 하는지 
* 메모리를 만드는 방법(RAM)
  1. 발진자 - 시간 잘 측정
  2. 클록 - 시간을 표현하는 근원을 만듦
  3. 래치 - 정보를 1비트 기억할 방법
  4. 게이트가 있는 래치 - 어느 시점에 무언가를 기억한다는 것
  5. 플립플롭 - 비트를 하나 기억
  6. 카운터 - 시간을 세는 방법
  7. 레지스터 - 쉽게 여러 비트를 저장
* 다양한 기억 장치
  * RAM, ROM
  * 블록장치
  * 플래시메모리 SSD
* 오류감지, 정정
* hardware vs software