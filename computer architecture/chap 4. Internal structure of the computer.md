# The secret life of programming 
 **Chapter 4. Internal structure of the computer**

- How computer hardward is structured
    - How to organize a computer using logic and memory
    - Different implementation methodologies
- modern computer's 3 parts
  1. memory
  2. I/O
  3. CPU


*** 
***
## **1. Memory**
    컴퓨터가 메모리를 어떻게 사용할까
        - 메모리는 집이 빈틈없이 늘어선 거리와 같다.
        - 모든 집은 크기가 똑같고 모든 집에는 정해진 개수만큼 비트를 저장할 수 있는 방이 있다.
        - 각 집에는 **주소(adress)**가 부여된다.

* 메모리 위치 : 구체적인 주소에 있는 메모리를 가리킬 때
* 메모리 구성
  * 32비트 컴퓨터 - 4 바이트 덩어리 (4차선)
  * 64비트 컴퓨터 - 8 바이트 덩어리 (8차선)
* 긴 워드의 주소 지정 방법
  * 포플렉스, 듀플렉스
  * 긴 워드 주소 > 워드 주소 > 바이트 주소
* 메모리 도로 (고속도로, 거리) (예시 - 32비트 컴퓨터)
  * 바이트마다 각기 다른 차선
  * 긴 워드는 도로 전체를 사용 
  * 좌석이 4개인 버스, 버스 좌석은 차선마다 하나씩
  * 오직 한 건물에만 정차해 비트를 태워서 도심으로 돌아온다
* **정렬이 맞지 않는 접근 방식(nonalignde access)** : 한 번에 두 건물에 걸쳐 있는 데이터를 읽는 경우
* 다양한 메모리의 **가성비**
  * 가격/성능 비율(price/performance ratio)
  * SRAM - 고속도로 : 빠르고 비싸다
  * 디스크 - 비포장도로 : 느리고 싸다
* **엔디안(endian)**
  * 도심을 오가는 버스의 각 자리에 누가 앉을까(0123? or 3210?)
  * 사용하는 프로세서에 따라 다르다 (리틀 엔디안[3, 2, 1, 0], 빅엔디안[0, 1, 2, 3])
  * 인텔 - 0번 바이트가 가장 오른쪽 VS 모토로라 - 0번 바이트가 가장 왼쪽 


***
## **2. Input and output**
    컴퓨터에 정보를 전달(**입력input**), 컴퓨터에서 정보를 가져옴(**출력output**) - I/O

* **I/O 장치** : I/O에 연결되는 장치, 컴퓨터 주변부에 위치 (**주변장치(peripheral)**)
* I/O 도로
  * I/O 처리를 위한 별도의 도로 (메모리 도로와 비슷)
  * 과거에는 I/O 도로와 메모리 도로를 분리
  * 요즘에는 메모리 거리 중 일부를 I/O 장치에 할당 (빈 주소가 많아져서)
* **슬롯(slot)**
  * 설계상 표준 I/O 슬롯이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다.
  * 과거 서부시대 땅 분배 방법 - 아무도 사용하지 않는 영역을 몇몇 사용 허가된 지역으로 나누고 각 슬롯을 차지한 장치는 자신에게 할당된 주소를 모두 사용 가능. (인구 조사용 특별 주소 : 도심에서 각 슬롯에 어떤 장치가 연결됐는지 파악)


***
## **3. Central Processing Unit**
    중앙 처리 장치(CPU)는 실제 계산을 처리하는 컴퓨터 부품 - 도심
    다른 모든 요소는 CPU를 지원하는 역할 

### **3-1. Arithmetic logic device**
ALU 산술 논리 장치는 CPU의 핵심 부품
산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치

- ALU 다이어 그램
  - 피연산자 : 수를 표현하는 비트
  - 연산코드 (명령코드) : 피연산자에 대해 ALU가 어떤 연산자를 적용할지 지정
  - 결과 : 피연산자에 연산자를 적용한 결과
  - 조건 코드 : 결과에 대한 추가 정보
- 조건 코드 레지스터 : 조건 코드가 저장되는 레지스터 (메모리 도로가 아닌 다른 곳에 존재하는 메모리)
  - N 비트 - 마지막으로 수행한 연산 결과가 음수인 경우 1로 설정
  - Z 비트 - 마지막 연산 결과가 0인 경우 1로 설정
  - O 비트 - 마지막 연산에서 오버플로나 언더플로가 생긴 경우 1로 설정
- ALU 명령코드 예제
  - 명령코드 종류 0000~1111
    - 0110, 0111, 1111 은 미사용
    - 명령코드|니모닉(mnemonic)|설명
    - 0000|clr            | (clear) : 모두 0으로

    명령코드|니모닉|설명
    ---------|----------|-----------
    0000|clr|clear 모든 비트 0으로
    0001|set|set 모든 비트 1로
    0011|not|B는 무시, A비트 중 0은 1로 1은 0으로
    0100|neg|B는 무시, A의 2의 보수인 -A가 결과
    0010|shl|A를 B의 하위 4비트값만큼 왼쪽으로 shift
    0101|shr|A를 B의 하위 4비트값만큼 오른쪽으로 shift
    0110||미사용
    0111||미사용
    1000|load|피연산자 B가 결과
    1001|and|A AND B
    1010|or|A OR B
    1011|xor|A XOR B
    1100|add|A + B
    1101|sub|A - B
    1110|cmp|B - A를 계산해서 조건 코드를 설정
    1111||미사용

    * ALU는 셀렉터와 논리 게이트를 연결한 것 뿐
    * 일반적인 ALU 설계(간략화)
    ![image/ALU%20design.png](image/ALU%20design.png)
     **<ALU의 내부(일부분)>**
     
### **3-2. Shift**
* 왼쪽 시프트 
  * 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고 비게 되는 가장 오른쪽 비트에 0을 넣는다.
  * 그 수에 2를 곱한 것과 같다.
* 오른쪽 시프트 
  * 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고, 맨 오른쪽 비트는 버리고 비게 되는 가장 왼쪽 비트에 0을 넣는다. 
  * 그 수를 2로 나누고 나머지를 버리는 것과 같다.
* MSB(가장왼쪽비트), LSB(가장오른쪽비트)값, 조건 레지스터에 저장
* CPU에서 O비트에 저장한다고 가정

* ALU의 모든 기능은 조합논리로 구현가능(shift제외)
* **시프트레지스터**
  * 클록에 따라 플립플롭을 사용해 만들 수 있다.
* **배럴시프터**
  * 셀렉터, 조합논리 사용(기본빌딩블록)
* 조합 논리 곱셈기
  * 배럴 시프터와 가산기를 조합
* 시프터는 부동 소수점 연산을 구현할 때도 핵심 부품 

### **3-3. Execution unit**
실행장치(execution unit) = 제어장치(control unit) 
* **실행장치**
  * ALU에게 할 일을 알려준다.
  * 결과를 메모리에 돌려준다.
* **프로그램 저장 방식 컴퓨터**
  * 메모리에서 명령어를 찾아 실행되는 컴퓨터
* **명령어**(instruction)
  * 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴
  * CPU마다 다르다 (공통표준x)
* **프로그램 카운터**(PC)
  * 실행 장치가 메모리에서 명령어를 가져와야 하는 위치를 알려 주는 도구
  * 일종의 큰 화살표, 우편배달부
  * 레지트서에 카운터 기능이 추가된 것
  * 메모리 주소가 들어 있어 메모리 위치를 가리킴.(**참조reference**)
  * CPU마다 초기 PC값이 있고 CPU전원이 들어오면 PC는 이 값으로 설정됨
* 마치 보물 찾기 처럼 컴퓨터는 메모리의 정해진 위치에서 쪽지를 찾고 쪽지에는 어떤 일을 해야 하는지 적혀 있다. 컴퓨터는 다른 장소로 이동해 다음 쪽지를 찾는다. 이런 과정을 반복하면서 프로그램을 실행한다.



***
## **4. Command Set**
### **4-1. Command**
### **4-2. Addressing mode**
### **4-3. Conditional code Command**
### **4-4. Branch Command**
### **4-5. Final Command set configuration**


***
## **5. Final Design**
### **5-1. Command register**
### **5-2. Data path and control signals**
### **5-3. Data flow control**


***
## **6. RISC and CISC Command Set**


***
## **7. GPU**



***
## **chapter 4 정리**
summary
- summary 1
  - key word 1
  - key word 2
- summary 2
  - key word 1
  - key word 2

  
><**Quotation**> 
description

[link example](extra%20search%20of%20chap1)

![image/image%20of%20book%20front.png](image/ALU%20design.png) **image example**