# 포스트 요약 정리
> https://d2.naver.com/news/3435170

# 백엔드 개발자의 진로
## 일의 범위
* 광범위, 상대적으로 모호, 전문화, 분업화되었다.
* 인접한 분야와 자주 소통 및 전문성을 키울 수 있는 기회가 많다.
* 그럼에도 어플리케이션을 잘 개발하는 능력은 중요하다.

## 보람과 고충
* 시스템을 안정적이고 효율적으로 만들 때 보람을 느낀다.
* 내면적인 부분까지 완성도를 추구하는 사람이 적합하다.
* 긴급한 상황에 항상 대비해야 한다.(항상 노트북 휴대, 당번제도)

## 향후 전망
* 새로운 도구와 프레임워크는 개발자들에게 더 큰 기회가 될 수 있다.
* 개발 분야에 따라서 전망이 갈릴 수 있지만, 개발 분야를 바뀔 수 있는 기회는 많다.
* 새로운 분야에 적응할 수 있는 역량을 키우는 것이 중요하다.

## 다른 분야로의 확장
* 프로젝트의 기획단계에서 개발자 의견 많이 반영된다.
* 경영의 경우, 직무와 상관없이 사람간의 관계, 갈등해결에 탁월한 사람이 적합
* 기술을 깊이 파고, 널리 쓰이는 프로그램을 만들고, 지식을 잘 전파하는 일에서 행복을 더 느끼는 개발자들, 즉 긍정적인 영향력을 크게 미치는 사람은 더 대우 받을 것.

# 백엔드 개발에 필요한 지식
* 웹 서버 개발 요소
    ```
    * 웹 생태계의 스펙
    * HTML, HTTP(1.1 , HTTP/2)
    * 기본 SDK, 라이브러리/프레임워크 이해와 활용
    * 클라이언트를 위한 API 설계
    * 서버/컴퍼넌트/객체 간의 역할 분담/의존성/통신 방법 설계
    * 저장소 활용
    * DBMS 설계
    * Cache 적용
        * Global/Local cache 적용범위, 라이프 싸이클, 솔루션 선택
    * 파일 저장 정책/솔루션 선택 활용
    * 검색엔진 연동 방식 결정
    * 빌드 도구
    * Maven/Gradle
    * 배포 전략
    * 성능 테스트/프로파일링/튜닝
    * JVM 레벨의 튜닝 (GC 옵션 등)
        * 웹 서버(Nginx,Tomcat)등의 설정/튜닝
    * OS 설정의 주요 값 확인
    * 인접 기술에 대한 이해
    * DBMS, Front End 등
    * 서버 개발자에만 해당하지는 않는 항목
    * 테스트 코드 작성/리팩토링 기법
    * 버전 관리 전략
        * branch 정책 등
    ```
* 팀원들의 지식이 합쳐서 구현 방식과 정책이 결정되므로 모든 요소를 깊이 잘 알아야 할 필요는 없다.
* 기술의 선택에 있어서 사용 경험이 있는 기술들을 택하되 운영환경에서의 모니터링과 문제해결에 있어 팀원들이 할 수 있는 기술을 선택
* 소수만 사용하는 관리 도구를 만들 경우 완전 새로운 기술을 사용하기도 하지만 새로운 기술은 위험성이 적은 서비스에 적용해 경험을 키운 후 큰 서비스에 적용

## 데이터 베이스
* 큰 서비스의 경우 다양한 저장소(RDB 가장 중요)를 활용하고 최근 단순한 SQL 추구한다.(캐시, 분산 저장이 쉽다.)
* Stored prodecure 가급적 사용 x
* 성능 향상을 위해 Local cache, Global cache 사용 
* 샤딩 - 저장 용량 많을 때 여러 개의 DB인스턴스에 나누어 저장
* RDB는 분산 비용이 비싸므로 성장 가능성일 클수록 자원을 아껴서 써야 한다.

## 개발툴
* 스스로 익힐 수 있고 적절한 도구를 선택할 수 있는 개발자
* 특정 도구를 익혔다는 것보다 새로운 도구가 나왔을 때 학습/적응/판단하는 능력이 실력
* 개발자의 수준 분류 (최소 레벨 2 이상)
```
* 레벨0 : 이미 쓰고 있는 개발도구의 사용법을 알려주거나 가이드 문서를 줘도 잘 못 씀
* 레벨1 : 알려주거나 같은 팀에서 만든 가이드 문서에 있는 만큼만 쓸 수 있음
* 레벨2 :
    * 개발도구의 공식 레퍼런스를 보고 사용법을 스스로 익힐 수 있음
    * 자신이 경험한 사용법을 문서화해서 팀 내에 전파할 수 있음
* 레벨3 :
    * 여러 개발도구를 비교 분석해서 상황에 적합한 도구를 선택할 수 있음
    * 공식 레퍼런스 문서에서 부족한 부분을 수정해서 기여할 수 있음
* 레벨4 :
    * 개발도구의 문제를 소스 코드를 수정해서 Fork/패치해서 사용할 수 있음
```

## 병렬처리
* Servlet기반의 Java웹서버들은 기본적으로 사용자의 요청을 병렬적으로 처리
1. Thread-safe한 변수만 사용
   * 객체가 멀티스레드에 공유되는것인지, 아닌지 의식하는 일은 중요
   * 클래스의 멤버변수에는 항상 멀티스레드에서 접근해도 안전한 변수만 두면 된다는 단순한 규칙만으로도 많은 문제를 예방 가능
2. Cache대상의 객체는 Immutable하게 유지
   * Local cachee를 적용할 때는 멀티스레드에서 공유된 객체가 쉽게 눈에 안띄므로 Cache대상의 객체는 Immutable하게 유지하는 것이 안전
   * 직접 Cache 모듈을 만드는 경우 위험한 버그가 생기는 경우가 많다.
     * 사례 - ['하나의 메모리 누수를 잡기까지'](https://d2.naver.com/helloworld/1326256)
3. 별도의 스레드 풀로 실행해야 할 작업
   * java - Executors, ThreadPoolExcutor 옵션들 사용 (직접 스레드 생성하는 방식은 jdk 5 이후로 권장하지 않는다.)

## 보안
* XSS, CSRF, SQL Injection 공격에 대처하는 방법은 모든 개발자가 알고 있어야 한다.
* 의존하는 라이브러리의 보안 취약점에 대처하는 경우가 많다.
  * 버전업, 자체 패치, 주요 변경을 알리는 메일링 그룹 가입으로 대처

## 테스트
* 테스트 코드를 작성하는 능력도 백엔드 개발자의 핵심역량
* 최근 백엔드 개발자들의 업무는 API 서버 개발에 더 집중되고 있다. UI와 통합하기 전 개발한 API를 스스로 테스트하는 필요성 증가.
* 서비스 중 오류시 수정 및 재배포 비용이 더 크다.
* HTTP API 테스트는 작성이 쉽고 이득도 크다.
  * HTTP API 통합 테스트( Rest-assured 와 Spring MVC Test Integration 을 이용)
* 라이브러리나 개발플랫폼을 개발하는 경우에도 테스트 코드는 중요 (최대한 모든 경로를 상상해서 테스트 코드를 작성)
* 테스트의 종류
    ```
    * 유지보수 기간의 생산성을 높여주고 새로 프로젝트에 투입될 사람에게도 이득을 주는 테스트
    * 프로젝트 오픈 일정 직전까지의 코드 변경과 버그 발견에 도움을 주는 테스트
    * 오늘 당장 프로그램을 목표한 곳까지 작성하는 일을 더 빨리 마치게 해주는 테스트
    ```
* Utilty 클래스 (main 메서드 안 > JUnit 안) > Spring framework 의 통합테스트 기능 (DB에 입력한 데이터를 자동으로 롤백시키는 기능 - DB와 연동된 테스트를 할 때 유용) > Mockito (더 정교한 테스트용 객체 생성 가능) > 테스트 코드 먼저 작성하는 기법 > 

## 자료구조/알고리즘
* SDK, 라이브러리에 자주 쓰이는 자료구조/알고리즘은 이미 구현되어 있다.
* 잘 선택하고 활용하기 위해서 바탕 지식으로서 중요
* JDK의 Collection framework 소스, Java HashMap의 동작 원리, 대용량 데이터의 저장, 탐색등에 있어서 자료구조는 중요하다.
* 자료구조 활용 사례 : B-Tree, B+Tree, PHOLAR 흔들림 보정원리

## 개발 프레임워크
* Spring/Netty 기반의 프레임워크들이 꾸준한 발전
  * 고부하 처리를 위한 서버에는 Netty
  * UI개발과 직접 호출되는 API 서버나 HTML까지 그리는 서버 개발에는 Spring 
* 비동기 I/O를 활용하는 서버 개발
* Spring 5에서 비동기 IO개발을 지원하는 Webflux 모듈도 주목을 받고 있다.
* 트래픽이 많아서 동기/쓰레드 기반으로는 자원을 효율적으로 쓸 수 없는 시스템에서는 택할만한 선택지

## Serverless
* Serverless : BaaS, FaaS에 의존하는 아키텍처
  * AWS의 람다, 네이버 클래우드 플랫폼의 Cloud Functions에 Serverless 아키텍처를 지원하는 플랫폼
* 폭넓게는 어플리케이션 코드를 작성하는 개발자가 서버관리를 신경쓰지 않는 구조나 역할분담을 해당 어플리케이션 입장에서는 'Serverless'라고 부르기도 한다.

# 실무에서 하는 고민
## 용어의 범위
* REST API 
  1. HTTP 프로토콜 위에서 JSON혹은 XML의 형식으로 통신하는 API
  2. 상태가 Hyper link를 통해 전이되어야 한다는 HATEOAS를 충족하는 API (Roy Fielding의 기준)
  * REST API의 범위에 대한 논란을 피하고 싶다면 HTTP API 혹은 Web API라고 칭하는 것이 무난
* TDD
  1. 테스트 코드를 작성하는 일을 통칭
  2. 테스트 작성, 테스트를 통과하는 코드 작성, 리팩토링의 싸이클을 거치는 것 (Kent Beck)
  * 뒤늦게 테스트를 추가하는 작업은 TDD라고 부르기보다는 '테스트 코드를 작성한다.'라는 표현이 무난
* '단위 테스트'
  1. JUnit으로 작성하는 코드(JUnit의 이름으로 인해 생긴 오해)
  2. JUnit으로 작성한 다양한 범위의 테스트 코드. 
  *  JUnit으로 만든 테스트 코드를 모두 '단위 테스트’라고 칭하는 것은 정교하지 못한 분류이고, 혼동의 소지가 있다.
* VO (Value Object)
  1. getter/setter만 있는, 값을 실어나르는 VO라고 칭하는 사람이 있는데 이는 DTO로 칭하는 것이 혼란의 여지가 적다.
  2. Value Object는 값에 의해 동등성이 판단되는 객체
* QP(Quality Practice)
  * 네이버에서 '품질향상을 위한 활동'을 지칭하는 용어로 사용 

## 클라이언트와 백엔드의 역할분담
* 예전에는 jsp와 같이 html을 서버사이드에서 생성하는 기술이 주로 사용
* Ajax는 서버 렌더링에 보조적으로 쓰이는 경향이 강했다.
* 하지만 요즘은 React.js나 Vue.js와 같은 프레임워크가 널리 쓰이면서 클라이언트 사이드에서 HTML을 생성하는 비중이 높아지고 있다. (React로 클라이언트 사이드에서 전적으로 HTML을 그린다.)
* 최근에는 사용자 처음 진입시에는 서버에서 그 이후로는 클라이언트에서 HTML을 그리는 Universal Rendering도 최근 많이 시도되고 있다.
*  HTML 렌더링 결정은 개발자간 역할분담에 영향.

## 클라이언트를 위한 API 설계
* HTTP API의 설계의 많은 부분은 매번 프로젝트마다 고민해야할 점이 많다.
  * 예로 CRUD API는 각각 POST/GET/PUT/DELETE의 HTTP 메서드로 연결시키더라도 이를 벗어난 기능들은 어떻게 설계해야할지 명확하지 않은 경우가 많다.
  * 페이징 처리를 할때나 복잡한 검색조건이 있을 때의 파라미터 표현방식에서도 서비스마다 다르게 정의하고 있다.
  * API에서 선택적으로 반환할 속성과 아닐 속성을 지정하는 방식도 다양하다.
* 지배적인 스펙이 존재하지는 않다.
* [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md)
* [JSON API 스펙](https://jsonapi.org/)
* REST 스타일과 유사한 틀 vs GraphQL(facebook에서 내놓은 HTTP API 툴)

## 시스템을 어떻게 자를것인가
* 시스템을 만들 때 많은 고민들은 결국 '구성요소 간의 역할과 책임을 어떻게 나눌 것인가'로 표현 가능. 
* 적게는 메서드, 클래스, 패키지 사이의 분담을, 크게는 jar로 배포되는 모듈이나 API로 통신을 하는 컴퍼넌트를 나누고 통신을 하는 방법을 고민
* 그리고 소프트웨어가 나누어진 경계에 맞추어 업무의 범위나 협업 방식이 정해진다.
* 최근 MSA(Micro Service Architecture)라는 구조가 각광을 받으면서 서버에 배포 가능한 모듈의 단위를 이전보다 작게 가져가는 경향이 나타나
* 많은 개발자가 동시에 협업하면서 개발하는데 MSA가 장점이 있다.

# 포스트 리뷰
인프런의 비전공자를 위한 개발자 취업 올인원 가이드 인강을 보다 참고자료로 이 포스트를 접하게 되었다.  
단순히 백엔드에 관한 기본적인 소개글이라고 생각하고 읽기 시작했는데 제목과 다르게 굉장히 전문적인 내용도 있었다. 실무를 경험해보지 않은 신입이나 초보 개발자에게는 꽤 어렵거나 이해하기 힘든 내용도 있어서 속독 1번과 정독을 2번하고 모르는 용어와 기술들을 찾아보며 공부를 꽤나 해야 하는 내용이었다. 
하지만 결론적으로 백엔드에 관해 막연한 느낌과 모호한 개념을 가지고 있었던 나로서는 큰 수익이었다. 오히려 첫 속독 때 느껴지던 어려움은 하나하나 글의 내용을 이해하게 되면서 백엔드 개발에 더 큰 흥미를 불러일으켰다. 또한 추후에 필요할 때 다시 보고 다시 복습하기위해 내용정리까지 하며 학습에 대한 열정을 되새겨주는 계기가 되었다. 아직 벡엔드와 프론트엔드를 선택하지 못한 나로서는 앞으로의 결정에 큰 영향을 끼칠 것이라고 생각되었다. 특히 네이버의 벡엔드 프로세스 예시에 관한 내용은 실무에 뛰어들고 나서 또 찾아보지 않을까 싶다.
