> ![](image/2022-03-29-11-34-51.png)  
> [jhta.step.or.kr](https://jhta.step.or.kr)

# 0329
# SQL활용

- [0329](#0329)
- [SQL활용](#sql활용)
- [1차시 데이터베이스](#1차시-데이터베이스)
  - [데이터베이스의 개념](#데이터베이스의-개념)
    - [데이터 베이스의 정의](#데이터-베이스의-정의)
      - [1. 공용 데이터](#1-공용-데이터)
      - [2. 통합 데이터](#2-통합-데이터)
      - [3. 저장 데이터](#3-저장-데이터)
      - [4. 운영 데이터](#4-운영-데이터)
      - [통합된 데이터란?](#통합된-데이터란)
    - [데이터베이스의 특징](#데이터베이스의-특징)
      - [내용에 의한 참조란?](#내용에-의한-참조란)
  - [데이터베이스 관리 시스템](#데이터베이스-관리-시스템)
    - [데이터베이스 관리 시스템의 정의](#데이터베이스-관리-시스템의-정의)
    - [데이터베이스 관리 시스템의 기능](#데이터베이스-관리-시스템의-기능)
    - [데이터베이스 관리 시스템의 역사](#데이터베이스-관리-시스템의-역사)
- [2차시 관계형 데이터 모델](#2차시-관계형-데이터-모델)
  - [관계형 데이터 모델의 구조와 연산](#관계형-데이터-모델의-구조와-연산)
    - [모델 D = `<S, O, C>`](#모델-d--s-o-c)
    - [관계형 데이터 모델을 사용하는 이유](#관계형-데이터-모델을-사용하는-이유)
    - [관계형 데이터 모델의 구조](#관계형-데이터-모델의-구조)
    - [릴레이션의 특징](#릴레이션의-특징)
    - [관계형 데이터 모델의 연산](#관계형-데이터-모델의-연산)
    - [관계 대수 연산자의 분류](#관계-대수-연산자의-분류)
    - [관계 대수 연산자의 분류](#관계-대수-연산자의-분류-1)
    - [순수관계 연산자](#순수관계-연산자)
  - [관계형 데이터 모델의 제약조건](#관계형-데이터-모델의-제약조건)
    - [키(Key)의 개념](#키key의-개념)
    - [무결성 제약조건](#무결성-제약조건)
- [3차시 SQL의 개념과 T-SQL](#3차시-sql의-개념과-t-sql)
  - [SQL의 개념](#sql의-개념)
    - [SQL의 역사](#sql의-역사)
    - [SQL의 특징](#sql의-특징)
    - [SQL 기본 구문](#sql-기본-구문)
      - [DDL문 : 데이터 정의문](#ddl문--데이터-정의문)
      - [DML문 : 데이터 조작문](#dml문--데이터-조작문)
      - [DCL문 : 데이터 제어문](#dcl문--데이터-제어문)
  - [T-SQL](#t-sql)
    - [MS-SQL](#ms-sql)
      - [MS-SQL Editions](#ms-sql-editions)
      - [MS-SQL의 설치와 구동](#ms-sql의-설치와-구동)
- [4차시 데이터 구조 생성과 변경](#4차시-데이터-구조-생성과-변경)
  - [테이블 생성](#테이블-생성)
    - [데이터베이스 생성](#데이터베이스-생성)
      - [T-SQL을 이용하여 데이터 베이스 만들기](#t-sql을-이용하여-데이터-베이스-만들기)
      - [SSMS를 이용하는 방법(GUI 이용)](#ssms를-이용하는-방법gui-이용)
    - [기본 데이터 타입](#기본-데이터-타입)
      - [숫자 타입](#숫자-타입)
      - [날짜(시간) 타입](#날짜시간-타입)
        - [문자 타입](#문자-타입)
      - [IDENTITY 타입](#identity-타입)
    - [테이블 생성과 튜플 추가](#테이블-생성과-튜플-추가)
      - [테이블 생성](#테이블-생성-1)
      - [튜플 추가](#튜플-추가)
      - [추가된 튜플의 검색](#추가된-튜플의-검색)
      - [SSMS를 이용한 테이블 만들기](#ssms를-이용한-테이블-만들기)
  - [테이블 변경](#테이블-변경)
    - [테이블 구조 변경](#테이블-구조-변경)
      - [ADD column : 속성 추가](#add-column--속성-추가)
      - [SSMS에서 테이블의 구조를 보는 방법](#ssms에서-테이블의-구조를-보는-방법)
      - [Drop table과 TRUNCATE table](#drop-table과-truncate-table)
- [5차시 제약조건](#5차시-제약조건)
  - [제약조건](#제약조건)
    - [1. 데이터 무결성](#1-데이터-무결성)
    - [2. 제약조건의 설정](#2-제약조건의-설정)
      - [테이블을 만들 때 속성에 제약조건 지정하기](#테이블을-만들-때-속성에-제약조건-지정하기)
      - [제약조건 설정 테이블 예제](#제약조건-설정-테이블-예제)
      - [제약조건 위반 튜플 삽입 예](#제약조건-위반-튜플-삽입-예)
      - [참조 무결성 제약조건](#참조-무결성-제약조건)
      - [참조 무결성 설정 및 삽입 오류의 예](#참조-무결성-설정-및-삽입-오류의-예)
      - [Check 제약조건](#check-제약조건)
      - [테이블 수준 제약조건](#테이블-수준-제약조건)
      - [테이블 수준 제약조건 설정의 예](#테이블-수준-제약조건-설정의-예)
  - [제약조건 변경](#제약조건-변경)
    - [1. 제약조건의 추가 및 제거](#1-제약조건의-추가-및-제거)
      - [테이블을 생성한 후에 제약조건을 추가하거나 제거할 필요성이 있음](#테이블을-생성한-후에-제약조건을-추가하거나-제거할-필요성이-있음)
      - [제약조건 이름을 지정해 두어야 추가나 제거가 쉬움](#제약조건-이름을-지정해-두어야-추가나-제거가-쉬움)
      - [제약조건 변경 예](#제약조건-변경-예)
- [6차시 데이터 검색](#6차시-데이터-검색)
  - [간단한 데이터 검색](#간단한-데이터-검색)
    - [1. AS 키워드와 *](#1-as-키워드와-)
      - [무조건 검색](#무조건-검색)
      - [\*](#)
      - [AS 키워드](#as-키워드)
    - [2. 간단한 조건 검색](#2-간단한-조건-검색)
      - [WHERE 절](#where-절)
      - [WHERE 절에서 비교하기](#where-절에서-비교하기)
      - [논리 연산자](#논리-연산자)
  - [복잡한 데이터 검색](#복잡한-데이터-검색)
    - [1. BETWEEN, IN, IS NULL](#1-between-in-is-null)
      - [BETWEEN a AND b](#between-a-and-b)
      - [IN(a, b, c, …)](#ina-b-c-)
      - [IS NULL](#is-null)
    - [2. 문자열 검색](#2-문자열-검색)
    - [3.. ORDER BY 절](#3-order-by-절)
- [7차시 데이터 삽입과 변경](#7차시-데이터-삽입과-변경)
  - [INSERT 절](#insert-절)
    - [1. 다양한 INSERT 구문](#1-다양한-insert-구문)
      - [단일행 입력](#단일행-입력)
      - [NULL의 입력](#null의-입력)
      - [서브 쿼리를 이용한 데이터 삽입](#서브-쿼리를-이용한-데이터-삽입)
      - [질의 결과 테이블 만들기](#질의-결과-테이블-만들기)
      - [테이블 구조의 복사](#테이블-구조의-복사)
      - [테이블의 구조 검색문](#테이블의-구조-검색문)
      - [VALUES를 이용한 다중행 입력](#values를-이용한-다중행-입력)
  - [UPDATE와 DELETE](#update와-delete)
    - [1. UPDATE 구문](#1-update-구문)
      - [데이터 수정](#데이터-수정)
      - [서브 쿼리를 이용한 데이터 수정](#서브-쿼리를-이용한-데이터-수정)
      - [복수 속성값 변경](#복수-속성값-변경)
      - [데이터 삭제](#데이터-삭제)
      - [서브쿼리를 이용한 데이터 삭제](#서브쿼리를-이용한-데이터-삭제)
- [8차시 트랜잭션](#8차시-트랜잭션)
  - [트랜잭션](#트랜잭션)
    - [트랜잭션의 개념](#트랜잭션의-개념)
      - [트랜잭션이란?](#트랜잭션이란)
      - [트랜잭션의 활용](#트랜잭션의-활용)
    - [트랜잭션이 없다면?](#트랜잭션이-없다면)
    - [트랜잭션의 특성](#트랜잭션의-특성)
      - [ACID](#acid)
      - [ACID와 DB 기능](#acid와-db-기능)
    - [3. 트랜잭션의 상태](#3-트랜잭션의-상태)
      - [트랜잭션의 상태 변화](#트랜잭션의-상태-변화)
  - [트랜잭션 제어문(TCL)](#트랜잭션-제어문tcl)
    - [1. 트랜잭션 제어문(TCL)](#1-트랜잭션-제어문tcl)
      - [COMMIT](#commit)
      - [ROLLBACK](#rollback)
      - [SAVEPOINT](#savepoint)
    - [2. 트랜잭션 모드](#2-트랜잭션-모드)
      - [MS-SQL은 3가지의 트랙잭션 모드를 지원함](#ms-sql은-3가지의-트랙잭션-모드를-지원함)
    - [3. 트랜잭션 제어문(TCL) 활용](#3-트랜잭션-제어문tcl-활용)
      - [간단한 트랜잭션 철회](#간단한-트랜잭션-철회)
      - [오류발생에 따른 트랜잭션 철회](#오류발생에-따른-트랜잭션-철회)
      - [SAVEPOINT를 이용한 트랜잭션 부분 철회](#savepoint를-이용한-트랜잭션-부분-철회)
- [강사님 공유자료](#강사님-공유자료)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

---
# 1차시 데이터베이스
## 데이터베이스의 개념
### 데이터 베이스의 정의
* 공동 통합 저장 운영
* 어떤 조직의 다양한 응용 프로그램들이 공동으로 사용하는 데이터들을 통합하여 저장한 운영 데이터의 집합

#### 1. 공용 데이터
* Shared Date
* 한 조직의 여러 응용 프로그램이 공동으로 사용하는 것
* 여러 사용자가 서로 다른 목적으로 공유함
#### 2. 통합 데이터
* Integrated Data
* 여러 부서에서 사용하는 데이터를 한 곳에 모아서 공동 관리하는 것
* 최소한의 중복, 통제된 중복
#### 3. 저장 데이터
* Stored Data
* 컴퓨터가 접근할 수 있는 디스크와 같은 저장매체에 저장된 것
#### 4. 운영 데이터
* Operational Data
* 조직의 운영에 기본적으로 반드시 필요한 데이터를 저장하는 것
* 조직의 고유한 기능을 수행하는 데 필수적인 데이터를 저장하는 것

#### 통합된 데이터란?
* 한 조직 내에서 여러 부서가 유사한 데이터 집합을 사용함
  * 예 : 학사 관리 시스템
    * 교무과 : 학교의 전반적 행정 사항 관리
    * 학적과 : 학생의 주요 정보(입학, 휴학, 복학, 자퇴 등) 관리
    * 학생과 학생의 장학금, 진학, 취업 등 지원
    * 학생정보를 3개의 부서가 사용함.
* 중복성 문제
  * 예 : 학사 관리 시스템
    * 각 부서가 독립적으로 학생 정보를 관리함
    * 학적과에서는 휴학중인 학생이 학생과에 의해서 근로 장학생으로 선발됨
      * 데이터의 일관성 문제 발생
* 통합된 데이터란?
  * 여러 부서가 사용하는 데이터를 통합하여 중복성을 없애고 일관성을 유지함
  * 각 부서가 데이터를 따로 가지고 있으면, 검색이나 운영 시에 편리함
  * 중복 -> 비일관성
    * 최소한의 중복
    * 통제된 중복

### 데이터베이스의 특징
1. 실시간 접근성
   * 질의에 대한 실시간 처리 및 응답
   * '만 7초이내 응답'
2. 계속적인 변화
   * 갱신, 삽입, 삭제 : 동적 특성
3. 동시 공용
   * 여러 사용자가 동시에 사용함
4. 내용에 의한 참조
   * 위치나 주소가 아닌 값에 따라 참조함

#### 내용에 의한 참조란?
* 프로그래밍 언어
  * 주소에 의한 검색
  * 메모리 주소
  * 변수
  * 데이터베이스에서의 검색
    * 프로그래밍 언어에서 변수(메모리 주소)를 가지고 데이터를 검색하는데  데이터베이스에서는 데이터 값(내용)을 가지고 검색한다.

## 데이터베이스 관리 시스템
### 데이터베이스 관리 시스템의 정의
* 데이터베이스
  * 관련 있는 데이터들의 집합
* 데이터베이스 관리 시스템
  * Database Management System(DBMS)
  * 데이터베이스를 생성 및 관리해주는 기능을 제공하는 소프트웨어 패키지/시스템
  * 데이터와 응용 프로그램 사이의 중계자
  * 모든 사용자와 응용 프로그램들이 데이터 베이스를 공유할 수 있도록 지원해주는 범용 목적의 소프트웨어 시스템
* 데이터베이스 시스템
  * DB + DBMS + 응용프로그램
  * 현실에서는 혼용해서 사용함
### 데이터베이스 관리 시스템의 기능
1. 데이터 정의 기능
   * 여러 사용자의 데이터를 통합하여 저장하고 공유할 수 있도록 데이터 모델에 따라서 정의하는 기능
2. 데이터 조작 기능
   * 사용자와 데이터베이스 간의 의사소통
   * 데이터베이스의 접근 및 조작 기능 제공
     * 삽입, 삭제, 변경 및 검색
   * 사용자가 사용하기 쉽고, 원하는 처리를 자연스럽게 표현할 수 있어야 함
3. 데이터 제어 기능
   * 데이터 일관성과 무결성, 보안을 유지하는 기능
     * 백업과 파손 회복
     * 인증과 보안
     * 병행제어

### 데이터베이스 관리 시스템의 역사
1. 1세대 DBMS
   * IDS(Integrated Data Store)
      * 최초의 범용 목적의 DBMS
      * 1960년대 초 GE의 Charles Bachman에 의하여 제시됨
      * Network Data Model 기반
   * IMS(Information Management System) DBMS
      * 1960년대 후반 IBM에서 제시함
      * 계층적 데이터 모델에 기반함
      * 1970년대 초 많은 회사들이 자신들만의 DBMS를 만들기 시작함

1. 2세대 DBMS
   * Relational Data Model, SQL
     * IBM의 E.F.Codd
   * Commercial DBMS
     * Oracle, DB2, Ingress, Sybase, Informix

3. 3세대 DBMS
   * 데이터의 복잡성 증가
     * Image, Video 등
   * 새로운 데이터 모델의 대두
     * 객체지향 데이터베이스

* 현재 DBMS
  * 2세대 DBMS(관계형) + 3세대 DBMS(객체지향) -> ORDBMS
  * 객체 관계형 데이터베이스 관리 시스템

---
# 2차시 관계형 데이터 모델
## 관계형 데이터 모델의 구조와 연산
### 모델 D = `<S, O, C>`
* Structure 구조
  * 데이터의 구조
  * 정적 성질, 개체 타입과 이들 간의 관계를 명세함
* Operation 연산
  * 데이터의 동적 성질
  * 개체 인스턴스를 처리하는 작업에 대한 명세
  * 데이터 조작 기법
* Constraint 제약조건
  * 데이터의 논리적 제약
  * 구조로부터 파생, 의미적 제약
  * 데이터 조작의 한계를 표현한 규정

* 데이터 모델의 예
  * 예 : 정수
    * 정수의 구조
      * ... -2, -1, 0, 1, 2, 3, ...
    * 연산
      * 사칙연산 +, -, *, /
    * 제약 조건 : 정수의 세계로 한정함
      * 정수/정수 -> 정의할 수 없는 경우가 있음
        * 5/2 -> 2.5 정수가 아님

### 관계형 데이터 모델을 사용하는 이유
* 모델의 구조가 단순함
* 집합이론 이라는 수학적 이론에 기반하여 모델이 강건함
* SQL이라는 간단한 비절차적 언어로 사용하기 쉬움

* 관계형 데이터 모델
  * 구조
    * 릴레이션(또는 테이블)
  * 연산
    * 관계 대수
  * 제약조건
    * 무결성 제약조건

### 관계형 데이터 모델의 구조
![](image/2022-03-29-10-18-06.png)
* 릴레이션
* 2차원 테이블 형태
* 테이블의 행 -> 튜플
  * 릴레이션의 튜플들의 집합
* 테이블의 열 -> 속성
  * 도메인: 속성이 가질 수 있는 값의 범위

### 릴레이션의 특징
1. 튜플의 유일성
   * 릴레이션은 튜플의 집합임
   * 집합은 중복을 허용하지 않음
2. 튜플의 무순서성
   * 릴레이션은 튜플의 집합임
   * 집합에서 원소들 간의 순서는 없음
3. 속성의 무순서성
   * 릴레이션 스키마는 속성들의 집합임
4. 속성의 원자성
   * 속성의 값은 원자값임
   * 논리적으로 더 분해할 수 없음

### 관계형 데이터 모델의 연산
* 관계 대수(Relational Algebra)
  * 시스템 관점
* 관계 대수와 SQL
  * 사용자 위주

### 관계 대수 연산자의 분류
* 일반 집합 연산자
  * 합집합
  * 교집합
  * 차집합
  * 카티션 프로덕트

### 관계 대수 연산자의 분류
* 일반 집합 연산자
  * 합병호환성
  * 합집합, 교집합 - 연산의 피연산자(릴레이션)들이 지켜야할 제약조건
    1. 차수가 같아야함
    2. 대응되는 속성 쌍 별로 타입이 같아야함
    3. 대응되는 속성 쌍 별로 의미가 같아야함
    * 1,2 조건은 시스템에서 확인해준다.
    * 3은 사람이 해야 한다.
    * 예시 : 몸무게, 키
      * 둘다 실수, 속성 1개.
      * 합치면 이해할 수 없는 데이터가 된다.
* 순수관계 연산자
  * 릴레이션이 2차원 구조기 때문에 유도되는 연산자
  * 셀렉트 (시그마)
  * 프로젝트 (파이)
  * 조인 
  * 디비전
  
### 순수관계 연산자
1. 셀렉트 (Select : $\sigma$(Sigma))
   * A, B가 릴레이션 R의 속성일 때
   * ![](image/2022-03-29-10-35-12.png)
   * $\Theta$(Theta): 비교 연산자
2. 프로젝트 (Project: $\pi$(PI))
   * 릴레이션 R(X)에서
   * ![](image/2022-03-29-10-39-32.png)
   * 프로젝트 ($\pi$)의 결과는 선택 조건을 만족하는 릴레이션의 수직적 부분집합
     * 폐쇄성질
     * 중복된 튜플들은 제거됨
    ![](image/2022-03-29-10-41-44.png)
3. 조인 (JOIN, ![](image/2022-03-29-10-43-19.png))
    * ![](image/2022-03-29-10-43-47.png)
    * ![](image/2022-03-29-10-44-49.png)
* 자연 조인(![](image/2022-03-29-10-46-35.png))
   * 일반적으로 아무 말 없이 조인이라고 하면 "자연 조인"을 말함
   * 두 테이블에 공통으로 나타나는 속성에 대한 동등 조인으로 간주

## 관계형 데이터 모델의 제약조건
### 키(Key)의 개념
* 하나의 내이블 내에서 각 튜플이 유일하게 식별할 수 있는 속성들의 집합
* 실생활의 키
  * 하나의 자물쇠를 열수 있는 열쇠는 오직 하나임
  * 생활의 편리성을 위하여 키를 복제하여 쓰지만 논리적으로는 하나임
* 후보키
  * 한 릴레이션 $R(A1, ..., An)$ 에 대한 속성의 집합 $K={Ai, ..., Aj}$으로 다음과 같은 성질을 만족함
    * 유일성 : 서로 다른 두 튜플의 속성집합 K의 값은 같지 않음
    * 최소성 : K는 서로 다른 두 튜플을 식별하기 위한 최소한의 속성들로만 이루어져 있음
* 수퍼키
  * 유일성을 만족하는 속성 집합
  * 최소성을 만족하지 않아도 됨
  * 일반적을 후보키는 수퍼키를 포함
* 기본키
  * 하나의 릴레이션에는 후보키가 여러 개 있을 수 있음
  * 여러 개의 후보키 중 DBA가 지정한 하나의 키임
* 대체키
  * 후보키 중 기본키를 제외한 나머지 후보키

* ![](image/2022-03-29-11-18-04.png)

* 외래키
  * 한 릴레이션 R1의 튜플과 다른 릴레이션 R2의 하나의 튜플과의 연관 관계를 표시하기 위하여 사용함
  * R1의 속성집합 FK의 도메인이 R2의 기본키 일 떄, FK를 R1의 외래키라 함
  * R1을 참조 릴레이션, R2를 피잡조 릴레이션이라고 함
    * R1과 R2가 다른 릴레이션일 필요는 없음

### 무결성 제약조건
* 개체 무결성
  * 의미
    * 서로 다른 두 튜플은 같을 수 없음
  * 정의
    * 기본키 값은 언제고 어느 때고 NULL 값일 수 없음
* 참조 무결성
  * 외래키 값은 피잠조 릴레이션의 기본키 값이거나 NULL값임
  * 추가 지정을 통해 NULL을 가질 수 없다고 제약을 걸 수 있음
* 도메인 무결성
  * 속성 값은 해당 속성 도메인에 속한 값들 중 하나이어야 함
    * 예 
      * 대학생의 학년 도메인 : 1,2,3,4 -> 9학년 10학년은 존재할 수 없음
  * DBMS는 데이터베이스의 상태변화(삽입,갱신,삭제)에도 항상 무결성 제약조건을 검사하고 유지시킴

---
# 3차시 SQL의 개념과 T-SQL  
## SQL의 개념
### SQL의 역사
* SEQUEL(Structured English Query Language)
  * 1974년 IBM San Jose Lab
  * 최초의 관계형 데이터베이스 관리 시스템 프로토타입인 SystemR을 위한 데이터베이스 언어로 개발됨
* SQL
  * 1986년 ANSI에서 관계형 데이터베이스 표준언어로 인증받음
  ![](image/2022-03-29-11-45-32.png)

### SQL의 특징
1. SQL은 무엇인가?
   * 종합 데이터베이스 언어 -> 데이터정의(DDL), 조작(DML), 제어(DCL)
     * 무엇을 표시하며 어떻게는 표시하지 않음
     * 어떻게는 DBMS가 알아서 처리함.
2. 왜 관계 대수식 대신 SQL을 사용하는가?
   * 관계 대수식 연산자 기호는 키보드로 표기하기 어려움
3. 관계 대수식과 SQL과의 차이점은 무엇인가.
   * 관계대수식
     * Relation
     * 튜플의 집합(Set)
     * 중복을 허용하지 않음
   * SQL
     * 튜플의 백
     * 튜플들 간의 순서는 없으나 중복을 허용함
   * 집합을 유지하려면 SQL의 결과에서 항상 중복되는 내용을 제거해야 함
   * 중복을 제거하는 것 = 튜플을 정렬하는 것과 같은 문제임
   * 결과 생성 시 시간이 오래 걸림 -> 성능 문제 발생

### SQL 기본 구문
#### DDL문 : 데이터 정의문
* 테이블 생성 : CREATE 문
  ```sql
  CREATE TABLE 테이블명
  ( 속성명 속성타입 [제약조건],
  속성명 속성타입,
  ...
  )
  ```
  * 제약 조건 : NOT NULL, PRIMARY KEY, UNIQUE
* 테이블 삭제 : DROP 문
  ```sql
  DROP TABLE 테이블명
  ```
  * 예 : 학생(STUDENT)테이블을 제거하시오
  ```sql
  DROP TABLE STUDENT
  ```
* 테이블 구조 변경 : ALTER 문
  * 속성 추가
    ```sql
    ALTER TABLE 테이블명 (ADD 속성명 속성타입)
    ```
  * 속성 제거
    ```sql
    ALTER TABLE 테이블명 (DROP 속성명 속성타입)
    ```
  * 속성 타입 변경
    ```sql
    ALTER TABLE 테이블명 (ALTER 속성명 속성타입)
    ```

#### DML문 : 데이터 조작문
* 튜플 삽입 : INSERT 문
  ```sql
  INSERT INTO 테이블명(속성명, 속성명, ...)
  VALUES (속성값, 속성값, ...)
  ```
* 튜플 변경 : UPDATE 문
  ```sql
  UPDATE 테이블명
  SET 속성명= 수식
  [WHERE 조건]
  ```
* 튜플 삭제 : DELETE 문
  ```sql
  DELETE FROM 테이블명
  [WHERE 조건]
  ```
* 트랜잭션 관련 : SELECT 문
  ```sql
  SELECT 속성명, 속성명, ...
  FROM 테이블명
  [WHERE 조건]
  ```

#### DCL문 : 데이터 제어문
* 트랜잭션 관련
  ```sql
  COMMIT
  ROLLBACK
  ```
* 사용자 권한 제어 관련
  ```SQL
  GRANT
  REVOKE
  DENY
  ```

## T-SQL
### MS-SQL
![](image/2022-03-29-12-21-22.png)
#### MS-SQL Editions
* MS-SQL Server
  * Microsoft에서 제공하는 데이터베이스 관리 시스템
* Edition 종류
  * Express
  * Workgroup
  * Standard
  * Enterprise
#### MS-SQL의 설치와 구동
* MS-SQL 구동 - Database
  * System Database
    * master : 시스템 관리용
    * model : 새 데이터베이스 생성을 위한 위한 틀
    * msdb : SQL Sever agent를 위한 데이터베이스
    * tempdb : 질의 임시결과 유지를 위한 테이블
  * User Database
    * SSMS 이나 T-SQL(SQL of MS SQL)을 이용해서 생성

--- 
# 4차시 데이터 구조 생성과 변경
## 테이블 생성
### 데이터베이스 생성
* 데이터베이스 - 밥상
  * 테이블(그릇)을 올리기 전에 데이터베이스(밥상)부터 만들어야 함
* MS-SQL에서 데이터베이스 만들기
  * T-SQL(Transact-SQL)
    * Text 입력
  * SSMS(SQL Server Management Studio)
    * GUI 이용
#### T-SQL을 이용하여 데이터 베이스 만들기
* DB 이름 : test01
* 사용자 DB를 생성하려면, master DB를 사용해야 함
  * `USE master`
  * `CREATE DATABASE test01`
#### SSMS를 이용하는 방법(GUI 이용)
* DB 이름 : test02
* 논리적 DB -> 물리적 파일
  * .mdf (for data), .ldf (for log), .ndf (for large DB -optional)

### 기본 데이터 타입
* DB(밥상)을 만들었으면 테이블(밥그릇)을 만들어야 함
* 어떤 모양의 테이블을 만들까?
  * MS-SQL에서 지원하는 기본 데이터 타입에는 무엇이 있을까?
#### 숫자 타입
* `bit`
  * 1 bit
* `tinyint`
  * 0~255 (정수)
* `smallint`
  * -2^15~2^15-1 (정수)
* `int`
  * -2^31~2^31-1 (정수)
* `bigint`
  * -2^63~2^63-1 (정수)
* `decimal[(p[,s])[, numeric([p[,s])]`
  * `decimal(5,2)` -> 123.45 (전체 자리수는 5자리, 소수점 아래 2자리까지 표시)
* `float`
  * 4byte, 8byte float (실수)
* `real`
  * 4byte, float (실수)
#### 날짜(시간) 타입
* `datetime`
  * 1755/1/1~9999/12/31 (8byte) (날짜)
* `smalldatetime`
  * 1990/01/01~2079/6/6 (4byte) (날짜)
##### 문자 타입
* `char[(n)]`
  * 고정 길이 문자열
* `varchar[(n)]`
  * 가변 길이 문자열
* `nchar[(n)]`
  * 유니코드를 위한 고정 길이 문자열
  * for unicode(2byte) -> n -> 2n bytes
* `nvarchar[(n)]`
  * 유니코드를 위한 가변 길이 문자열
  * for unicode(2byte)
#### IDENTITY 타입
* 자동 증가 속성 타입
* 정수형 타입
* `IDENTITY(10,2)` -> 초기값 10, 2씩 증가
  * 10, 12, 14, ...

### 테이블 생성과 튜플 추가
#### 테이블 생성
```sql
CREATE TABLE 테이블명
( 속성명 속성타입 [제약조건],
속성명 속성타입,
...
)
``` 
* test01 DB에 테이블을 만들 것이므로 use test01 기입

#### 튜플 추가
```sql
INSERT INTO 테이블명(속성명, 속성명, ... )
VALUES (속성값, 속성값,…)
``` 
* INTO 생략가능

#### 추가된 튜플의 검색 
```sql
SELECT 속성명, 속성명,…
 FROM 테이블명
 [ WHERE 조건 ]
``` 

#### SSMS를 이용한 테이블 만들기
1. 테이블 선택(마우스 오른쪽 버튼 선택)
2. 속성 이름과 타입 선택
3. 테이블 이름 입력

## 테이블 변경
### 테이블 구조 변경
* 테이블의 구조 변경(ALTER TABLE) 
  * `ADD column` : 속성 추가
  * `ALTER column` : 속성 타입 변경
  * `DROP column` : 속성 제거
```sql
ALTER TABLE 테이블명{
{ADD|ALTER|DROP} [COLUMN] 속성명 [타입]
}
```

* 주의 사항
  * ALTER column의 경우 속성값의 범위를 증가 시키는 경우에는 문제가 없지만 범위를 감소시킬 경우에는 현재 테이블이 저장된 속성값들에 따라서 허용이 안될 수도 있음
    * 예 : 
      * 이름 속성값으로 “김이름씨”, “박이름씨”, “이름이이뻐요” 등이 저장되어 있을 때
  * 속성 타입은 varchar(3)로 변경하려고 하면 안됨
    * 모두 6byte 이상임(한글 1자는 2byte)
  * varchar(50)으로는 변경 가능함

#### ADD column : 속성 추가
* datetime형으로 pdate 속성을 memberTEST 테이블에 추가
  ```sql
  ALTER TABLE memberTEST
  ADD pdate datetime
  ```
* name 속성의 타입을 varchar(30)으로 변경함
  ```sql
  ALTER TABLE memberTEST
  ALTER column name varchar(30)
  ```

#### SSMS에서 테이블의 구조를 보는 방법 
1. 테이블 선택(마우스 오른쪽 버튼 클릭) 
2. 디자인 선택

#### Drop table과 TRUNCATE table 
* 테이블을 지우기 
`DROP TABLE table_name`
* 테이블의 모든 내용을 지우기, 단 테이블은 남기기 
`TRUNCATE TABLE table_name`

* 주의 사항 
  * CREATE, ADD, ALTER, DROP, TRUNCATE 등은 모두 데이터 정의어 (DDL)임
  * 명령문이 수행되고 나면 회복이 불가능함

---
# 5차시 제약조건
## 제약조건
### 1. 데이터 무결성 
* NOT NULL 
 * NULL 값 허용 불가
   * 예 : 학생 테이블에서 학생의 이름은 NULL값일 수 없음
* UNIQUE 
 * 하나의 테이블 내에서 한번만 나옴
 * 주로 대체키 설정 시 사용됨
* PRIMARY KEY 
 * 기본키
   * 의미 : UNIQUE + NOT NULL
* FOREIGN KEY 
 * 외래키
* CHECK 
 * 도메인 무결성

### 2. 제약조건의 설정 
#### 테이블을 만들 때 속성에 제약조건 지정하기 
```SQL
CREATE TABLE 테이블명
( 속성명 속성타입 [ [제약조건명] 제약조건],
 속성명 속성타입,
 …
)
```
* 예 :
```SQL
name varchar(20) NOT NULL
id int CONSTRAINT PK_01 PRIMARY KEY
```
#### 제약조건 설정 테이블 예제 
![](image/2022-03-29-15-03-00.png)
#### 제약조건 위반 튜플 삽입 예 
![](image/2022-03-29-15-03-44.png)
#### 참조 무결성 제약조건 
* 외래키 값은 다른 테이블의 기본키 값들 중에 하나이어야 함
  * 예 : 사원 테이블의 부서번호는 부서 테이블의 기본키 값들 중 하나이어야 함
    ```SQL
    속성명 [CONSTRAINTS 제약조건명] 
    REFERENCE 참조테이블명(속성명)
    ```
#### 참조 무결성 설정 및 삽입 오류의 예 
![](image/2022-03-29-15-04-45.png)
#### Check 제약조건 
* 도메인 무결성 제약조건
* 입력 값의 제한
  * 예 :
    ```SQL
    birthYear int CHECK(birthYear >= 1900)
    Age int CHECK(Age between 1 and 150)
    ```
#### 테이블 수준 제약조건 
* 속성 단위로 제약조건 설정은 표현에 있어서 제약이 따름
  * 복합키의 경우(여러 개의 속성이 합쳐져서 키가 됨) 등
* 구문
```SQL
CREATE TABLE 테이블명(
 속성명 속성타입
 ...
 [CONSTRAINT 제약조건명] 제약조건(속성명)
)
```
#### 테이블 수준 제약조건 설정의 예 
![](image/2022-03-29-15-05-13.png)

## 제약조건 변경
### 1. 제약조건의 추가 및 제거
#### 테이블을 생성한 후에 제약조건을 추가하거나 제거할 필요성이 있음 
* 제약조건도 테이블의 구조 정보에 속함으로 ALTER TABLE을 이용함
* 추가
  * `ADD CONSTRAINT`
* 제거
  * `DROP CONSTRAINT`
#### 제약조건 이름을 지정해 두어야 추가나 제거가 쉬움 
```SQL
ALTER TABLE 테이블명
ADD [CONSTRAINT 제약조건명] 제약조건 (속성명)
```
```SQL
ALTER TABLE 테이블명
DROP CONSTRAINT 제약조건명
```
#### 제약조건 변경 예 
![](image/2022-03-29-15-08-59.png)

---
# 6차시 데이터 검색
## 간단한 데이터 검색
### 1. AS 키워드와 * 
* 실습용 데이터 생성 
  * 실습을 위한 테이블 및 튜플들을 생성함
     * `5SQLDatapopulate.sql`
     * DB 이름 : MagicCorp
     * 테이블 : DEPARTMENT, EMPLOYEE, SALGRADE
     * 
  1. File ⇨ Open ⇨ File…
  2. 실습용 파일 선택
  3. 실행

#### 무조건 검색 
```sql
SELECT 속성명1, 속성명2,…
FROM 테이블명
```
* 모든 부서 정보 검색
  * ![](image/2022-03-29-15-50-57.png)

#### \*
* 모든 속성명을 쓰기 힘듦
  * “*” 를 사용함
  * SELECT절에서 *는 모든 속성이란 의미임
* 모든 부서 정보 검색
  * ![](image/2022-03-29-15-51-44.png)

#### AS 키워드 
1. 질의 결과의 속성명을 바꾸어서 나타나게 함
2. 질의결과에 수식을 넣을 수 있음
3. 속성명이 없음
4. AS 키워드로 속성명을 부여함

* 사원 테이블에서 사원명과 봉급*12 검색
  * ![](image/2022-03-29-15-53-05.png)


### 2. 간단한 조건 검색 
#### WHERE 절 
* 사원 테이블(EMPLOYEE)에서 사원번호(ENO) 110번의 이름(ENAME)과
부서번호(DNO) 검색
  * 조건 : 사원번호 110번
  * WHERE 절을 사용함
* ![](image/2022-03-29-15-55-38.png)

#### WHERE 절에서 비교하기
* WHERE 절에서 문자, 숫자, 날짜의 크기나 순서를 비교함
  * 같다 : =
  * 같지 않다 : !=, <>
  * 크다 : >
  * 크거나 같다 : >=
  * 작다 : <
  * 작거나 같다 : <=

#### 논리 연산자 
* WHERE 절에서 여러 개의 조건을 결합할 경우 
  * X AND Y : X, Y가 참일 때 참을 반환
  * X OR Y : X나 Y가 참일 때 참을 반환
  * NOT X : X가 거짓일 때 참을 반환

* 사원 테이블에서 부서번호(DNO)가 20번이고 봉급(SALARY)이 400이상인
사원의 이름(ENAME)과 직책(JOB) 검색
  * 조건 : DNO = 20 AND SALARY >= 400

* DISTINCT 
  * SQL은 Bag 을 기반으로 함
    * 중복된 것들도 다 나옴
  * 중복된 것을 제거하고 한번만 나오게 하는 방법
    * DISTINCT를 사용함
    * 예 : `SELECT DISTINCT 속성명 …`

  * 사원 테이블에서 모든 직급(JOB) 검색
    * ![](image/2022-03-29-15-58-19.png)
  * 사원 테이블에서 모든 직급을 중복 없이 검색
    * ![](image/2022-03-29-15-58-25.png)


## 복잡한 데이터 검색 
### 1. BETWEEN, IN, IS NULL 

#### BETWEEN a AND b 
* 검색 조건의 상한과 하한을 지정함
  * 속성 X가 10보다 크거나 같고 50보다 작거나 같음
  * X>=10 AND X<=50
    * X BETWEEN 10 AND 50
* 사원 테이블에서 봉급이 400보다 크거나 같고 600보다는 작거나 같은
사원들의 정보 검색
  * ![](image/2022-03-29-15-59-48.png)

#### IN(a, b, c, …) 
* 속성값이 a, b, c ,… 중 하나라도 일치하면 참
  * 속성 X가 10이거나 20이거나 30임
  * X = 10 OR X = 20 OR X = 30
    * `X IN(10, 20, 30)`

* 직급이 ‘section’이거나 ‘senior’인 사원들의 이름과 직급 검색
  * ![](image/2022-03-29-16-01-43.png)

#### IS NULL 
* NULL 값은 어떤 비교를 하든 거짓임
  * 사원 테이블에서 COMMISSION 값이 NULL인 튜플들이 있을 경우
    1. X = NULL ⇨ X가 NULL 값이어도 이 결과는 거짓
    2. 결과가 없음
      * ![](image/2022-03-29-16-02-39.png)
        * ⇨ IS NULL을 이용함
      * ![](image/2022-03-29-16-02-50.png)
  * NULL 값이 아닌 것들을 찾는 방법
    * ⇨ IS NOT NULL을 이용함
      * ![](image/2022-03-29-16-03-42.png)

### 2. 문자열 검색 
* LIKE 연산자 
  * 컬럼에 저장된 문자열 중에서 LIKE 연산자에서 지정한 문자 패턴과 부분적으로 일치하면 참이 되는 연산자
* 부분 문자열 검색에 사용되는 패턴 
  * `%` : 임의의 길이의 문자열
  * `_` : 글자 한자
  * 부서 테이블에서 부서명(DNAME)이 H로 시작하고 n으로 끝나는 부서의
  위치(Loc) 검색
    * ![](image/2022-03-29-16-04-35.png)

* 질의문의 결과는 테이블에 입력된 순서대로 출력됨 
  * 데이터의 출력 순서를 특정 속성값을 기준으로 오름차순 또는 내림차순으로 정렬해야 하는 경우가 자주 발생함
  * 복잡한 데이터 검색 

### 3.. ORDER BY 절 
* ORDER BY 절 
  * `ORDER BY {column_name} [ASC|DESC]`
    * ASC : 오름차순으로, 기본값(생략가능)
    * DESC : 내림차순, 생략불가능
  * 봉급(Salary) 기준 내림차순으로 사원들의 이름, 봉급, 부서 번호 출력
    * ![](image/2022-03-29-16-06-14.png)

* 다중 속성 정렬
  * 봉급(Salary) 기준 내림차순으로 사원들의 이름, 봉급, 부서 번호 출력
    * ![](image/2022-03-29-16-06-20.png)
    * 봉급이 같은 경우에는 부서번호가 낮은 순으로(오름차순) 정렬함

---
# 7차시 데이터 삽입과 변경
## INSERT 절
### 1. 다양한 INSERT 구문 
#### 단일행 입력 
한번에 하나의 튜플을 테이블에 입력하는 방법 
```sql
INSERT INTO 테이블명 [(속성명,…, 속성명)]
VALUES (값,…, 값)
```
* “INTO”는 생략이 가능함
* 테이블명에 명시한 속성에 VALUES절에 지정한 값을 입력함
* 테이블명에 속성을 명시하지 않으면 테이블 생성시 정의한 컬럼 순서와 동일한 순서로 입력함

* 실습을 위하여 사원과 같은 구조의 테이블 EMPTEST 생성
  * ![](image/2022-03-29-16-56-50.png)
* EMPTEST 테이블에 사원 정보 삽입
* 50, “홍길동”, “staff”, NULL, 2012-10-01, 500, 30, 10
  * ![](image/2022-03-29-16-56-39.png)

1. 다양한 INSERT 구문 
4
#### NULL의 입력 
데이터를 입력하는 시점에서 해당 속성값을 모르거나, 미확정일 때 사용함 
NOT NULL 조건이 지정된 경우 입력이 불가능함 

* 묵시적인 방법
  * INSERT INTO 절에 해당 속성명 생략
* 명시적인 방법
* VALUES 절에 있는 속성값에 NULL을 사용

* EMPTEST 테이블에 묵시적인 방법을 이용하여 사원 번호(51)와 사원이름(‘심청이’) 입력, 나머지는 NULL 입력
  * ![](image/2022-03-29-16-55-53.png)
* EMPTEST 테이블에 명시적인 방법을 이용하여 사원 번호(52)와 사원이름(‘임꺽정’) 입력, 나머지는 NULL 입력
  * ![](image/2022-03-29-16-55-28.png)

#### 서브 쿼리를 이용한 데이터 삽입 
* 서브 쿼리의 결과를 테이블에 삽입함
```sql
INSERT INTO 테이블
subquery
```
  * 한번에 여러 튜플을 넣을 수 있음
  * 서브쿼리의 결과 집합은 INSERT 명령문에 지정된 칼럼 개수와 데이터 타입이
  일치해야 함
* 사원 테이블에서 부서번호 30인 사원들을 EMPTEST에 삽입
  * ![](image/2022-03-29-16-54-59.png)


#### 질의 결과 테이블 만들기 
* 질의 결과를 바로 테이블 만들고 저장하기
```SQL
SELECT 컬럼리스트 INTO 대상테이블
FROM 테이블
WHERE 조건
```
* 부서 테이블에서 부서번호 30인 부서의 부서번호와 부서명을 DEPTEST란
테이블로 저장
  * ![](image/2022-03-29-16-54-25.png)
* 오라클의 경우에는 구문이 다소 다름
```SQL
CREATE TABLE 테이블명
AS 
SELECT 컬럼리스트
FROM 테이블
[WHERE 조건]
```
1. 질의 결과로 만든 테이블은 기존 테이블의 속성명과 타입을 그대로 적용함
2. NOT NULL 조건을 그대로 적용함
3. 다른 제약조건은 적용되지 않음

#### 테이블 구조의 복사 
* 상황에 따라서 기존 테이블과 동일한 구조를 지니는 테이블을 생성할 필요가 있음
  * 구조만 복사하고 튜플들은 복사하고 싶지 않은 경우
* `SELECT ~ INTO ~` 구문을 이용함
* WHERE 조건에 항상 거짓이 되는 조건을 기술함
  * 예 : 1 > 2
* DEPARTMENT의 구조만 복사하여 DEPT_COPY 테이블 생성
  * ![](image/2022-03-29-16-53-24.png)

#### 테이블의 구조 검색문 
* 오라클
  * 명령어 : DESCRIBE[DESC] 테이블명
* MS SQL
  * 저장 프로시저 : sp_help 테이블명
  * 저장 프로시저를 수행시키기 위하여 EXEC 명령어가 필요함
* DEPTEST의 튜플들과 구조정보 검색
  * ![](image/2022-03-29-16-52-48.png)

#### VALUES를 이용한 다중행 입력 
* MS-SQL 2008 부터는 서브 쿼리가 아닌 VALUES를 이용해서도 다중행 삽입이 가능함
```SQL
INSERT INTO table1
VALUES (속성값들), (속성값들)
```
* ![](image/2022-03-29-16-52-41.png)

## UPDATE와 DELETE 
### 1. UPDATE 구문 
#### 데이터 수정 
* UPDATE 문 : 테이블에 저장된 데이터를 수정하기 위한 데이터 조작어
```SQL
UPDATE 테이블명
SET column = 값, ...
[WHERE 조건]
```
* WHERE 절이 생략되면 테이블의 모든 행이 수정됨
* EMPTEST에 있는 모든 사원의 봉급 10% 인상
  * ![](image/2022-03-29-16-51-28.png)

* EMPTEST에 있는 사원들 중 30번 부서에 속한 사원들의 직급 모두 staff로 변경
  * ![](image/2022-03-29-16-51-04.png)

#### 서브 쿼리를 이용한 데이터 수정 
* UPDATE문의 SET 절에서 서브 쿼리를 이용함
* 다른 테이블에 저장된 데이터를 검색하여 한번에 여러 속성값을 수정할 수 있음
* SET 절의 속성명은 서브 쿼리의 속성명과 달라도 됨
```SQL
UPDATE table
SET 속성1 = (SELECT ~ FROM ~ WHERE~)
[WHERE 조건] 
```
* EMPTEST 테이블에서 사원번호 50번인 사원의 관리자번호
  * ⇨ 사원테이블의 사원번호 101번의 값으로 변경
* ![](image/2022-03-29-16-50-00.png)

#### 복수 속성값 변경 
* 하나 이상의 속성값 한번에 변경하기
   * SET 절에 (속성명 = 값), (속성명= 값), … 으로 작성함
  ```SQL
  UPDATE table
  SET 속성1 = 값, 속성2 = 값, …
  [WHERE 조건] 
  ```
* EMPTEST 에서 eno가 51인 튜플
* ⇨ SALARY를 300으로 변경
* ⇨ COMMISSION은 50으로 변경
* ![](image/2022-03-29-16-49-46.png)

#### 데이터 삭제 
* DELETE 문 : 테이블에 저장된 데이터 삭제를 위한 조작어
```sql
DELETE [FROM] 테이블
[WHERE 조건]
```
* WHERE 절이 생략되면 테이블의 모든 행을 삭제함
* DEPTEST에 있는 모든 정보를 삭제
  * ![](image/2022-03-29-16-48-15.png)

* EMPTEST에서 급여가 400 미만인 사원 제거
  * ![](image/2022-03-29-16-47-55.png)

#### 서브쿼리를 이용한 데이터 삭제 
* WHERE 절에서 서브 쿼리를 이용함
* 다른 테이블에 저장된 데이터를 검색하여 한번에 여러 행을 삭제함
* WHERE 절의 속성명은 서브 쿼리의 속성명과 달라도 됨
* 부서명이 Accounting인 부서에 속한 사원들을 EMPTEST 테이블에서 삭제하기
  * ![](image/2022-03-29-16-47-28.png)

---
# 8차시 트랜잭션
## 트랜잭션 
### 트랜잭션의 개념
#### 트랜잭션이란? 
* 트랜잭션(Transaction) : 논리적인 일의 단위
* 기본 설정
  * **하나의 SQL은 하나의 트랜잭션임** 
  * 여러 개의 SQL문들이 합쳐져서 하나의 트랜잭션이 될 수도 있음
#### 트랜잭션의 활용
![](image/2022-03-29-17-33-56.png)  
* **대규모 데이터베이스를 수백, 수천 명 이상의 사용자들이 동시에 접근함**   
* **많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함**
  * ⇨ 동시성

* 동시성 제어
  * 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향 = 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장함
  * 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
  * 여러 사용자나 여러 응용 프로그램들이 동시에 수행되어도 서로 간섭하지 못하도록 보장함
  * ⇨ 트랜잭션 단위, 동시성 제어
* 회복
  * 데이터베이스를 갱신하는 도중에 시스템 고장 시에도 데이터베이스의 일관성을 유지함
  * ⇨ 트랙잭션 단위 회복

### 트랜잭션이 없다면? 
1. 은행 계좌 이자 증가
   * 전체 계좌들에 대한 이자가 모두 계산되어야 함
   * 만약 일부 계좌 이자만 증가되고 컴퓨터가 다운되었다가 재가동 된다면?
   * ⇨ 처음부터 다시 계산하면 이중 이자 계산이 됨
2. 다양한 예약 시스템
   * 항공권, 극장 등의 예약 시스템
   * 좌석을 선점하고 돈을 내기 전에 시스템이 다운됨
   * 돈은 내지 않았지만 좌석을 잡았기 때문에 해당 좌석은 절대 다시 잡을 수 없어짐
3. 은행 계좌 이체 : A계좌에서 100원을 빼서 B계좌에 넣기
* 계좌 이체 시 장애발생
  ```sql
  UPDATE ACCOUNT
  SET BALANCE = BALANCE - 100
  WHERE ID = A
  ```
  장애가 발생
  ```sql
  UPDATE ACCOUNT
  SET BALANCE = BALANCE + 100
  WHERE ID = B
  ```
   * A 통장에서 돈만 빠져 나가고 B통장에 돈이 안 들어옴
   * ⇨ 은행이 고객의 돈을 횡령한 것이 됨

* 횡령을 피하기 위해 먼저 B 계좌에 돈을 입금…
  ```sql
  UPDATE ACCOUNT
  SET BALANCE = BALANCE + 100
  WHERE ID = B
  ```
  장애가 발생
  ```sql
  UPDATE ACCOUNT
  SET BALANCE = BALANCE - 100
  WHERE ID = A  
  ```

  * B 통장에서 돈이 들어 왔는데 A 통장에 돈이 안 빠짐
  * ⇨ 은행에 막대한 손실이 발생함

* 두 개의 SQL을 모아서 하나의 트랜잭션(계좌이체 업무)으로 관리함
  * **두 DML문은 하나의 업무에 속한 작업들임**

### 트랜잭션의 특성
#### ACID 
1. Atomicity : 원자성
   * 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(All or 
Nothing)을 의미함
   * DBMS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를
갱신한 트랜잭션의 영향을 취소함으로써
   * 트랜잭션의 원자성을 보장함
   * 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의
원자성을 보장함
2. Consistency : 일관성
   * 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면
트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
   * 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지
않을 수 있음
3. Isolation : 격리성
   * 고립성이라고도 함
   * 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인
데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
   * 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라
트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
   * DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
   * DBMS는 응용들의 요구사항에 따라 다양한 고립 수준(Isolation Level)을 제공함
4. Durability : 영속성
   * 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에
고장이 발생하더라도 손실되지 않음
   * 완료된 트랜잭션의 효과는 시스템이 고장 난 경우에도 데이터베이스에 반영됨
   * DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함

#### ACID와 DB 기능 
* ACID 특성과 DB의 기능은 모두 다 연관이 있음(연관성이 높은 순서)
  * DB 회복 기능 : 원자성과 지속성에 연관됨
  * DB 동시성 제어 : 일관성과 고립성에 연관
  * 무결성 제약 조건 : 일관성과 관련

### 3. 트랜잭션의 상태 
#### 트랜잭션의 상태 변화 
![](image/2022-03-29-17-33-39.png)


## 트랜잭션 제어문(TCL) 
### 1. 트랜잭션 제어문(TCL)
#### COMMIT 
* 트랜잭션의 마지막 명령어가 수행되었음을 나타냄
* 트랜잭션에 의한 변경을 확정
* COMMIT된 트랜잭션은 철회가 불가능함
* COMMIT 명령문 실행하기 전에 하나의 트랜잭션 변경한 결과를 다른
트랜잭션에서 접근할 수 없도록 방지하여 일관성을 유지함
#### ROLLBACK 
* 트랜잭션의 변경을 취소하고 트랜잭션 종료
#### SAVEPOINT 
* 현재 트랜잭션에서 ROLLBACK 시킬 위치 지정
* 대규모 트랜잭션(복수개의 명령어들로 이루진 트랜잭션)에서 오류 발생이 전체 트랜잭션을 취소 시키는 것이 큰 부담이 될 수 있음
* 실패한 일정부분만 취소 시키도록 함

### 2. 트랜잭션 모드 
#### MS-SQL은 3가지의 트랙잭션 모드를 지원함 
1. 자동 커밋 트랜잭션
   * 하나의 명령문이 하나의 트랙잭션이 됨
   * MS-SQL에서 기본 모드임
2. 명시적 트랜잭션
   * 명시적으로 사용자가 트랙잭션을 정의하는 형태
   * `BEGIN TRAN ~ COMMIT TRAN(또는 ROLLBACK TRAN)`으로 이루어짐
3. 묵시적 트랜잭션
   * 자동 커밋 트랜잭션의 반대되는 개념
   * 사용자가 `COMMIT TRAN(또는 ROLLBACK TRAN)`을 입력하기 전까지 복수 개의 명령문을 하나의 트랜잭션으로 간주함
   * `BEGIN TRAN`이 필요 없음
   * 묵시적 트랜잭션의 설정
     * `SET IMPLICIT TRANSACTIONS {ON|OFF}`
   * 트랜잭션 종료마다 사용자가 반드시 `COMMIT / ROLLBAK`을 명령문을 실행시켜야 함
   * 고급 사용자가 아닌 이상 가능한 사용하지 않는 것이 좋음

### 3. 트랜잭션 제어문(TCL) 활용 
#### 간단한 트랜잭션 철회 
* 실습을 위하여 DEPARTMENT 테이블 내용을 DEPT01로 복사하기
  * ![](image/2022-03-29-17-39-49.png)
* 트랜잭션을 시작한 후 DEPT01 테이블의 내용을 모두 지우고 트랜잭션 취소를 시켜보기
  1. 트랜잭션을 시작
  2. DEPT01 테이블 내용 지우기 ⇨ DEPT01 내용 보기
  3. ROLLBACK ⇨ DEPT01 내용 보기
  * ![](image/2022-03-29-17-39-55.png)

#### 오류발생에 따른 트랜잭션 철회 
* 트랜잭션을 구성하는 명령문들 중 : 
  * 오류 발생 ⇨ 트랜잭션 철회
  * 오류 발생하지 않음 ⇨ 완료
* MS-SQL에서 명령문의 오류는 @@ERROR라는 변수에 저장됨
* T-SQL에서 `IF ~ ELSE ~` 및 `GOTO` 같은 구문을 사용할 수 있음
* DEPT01 테이블의 DNO는 NULL값이 올 수 없음
  * 테이블 구조정보 보는 법 : `EXEC sp_help 테이블명`
  * ![](image/2022-03-29-17-41-43.png)
* 하나의 트랙잭션을 이용함
  1. DEPT01 테이블에서 부서번호 10번 튜플을 삭제함
  2. (NULL, ‘PRODUCT’, ‘Seoul’) 튜플을 삽입 ⇨ 오류 발생
  3. 오류가 발생하면 해당 트랜잭션을 ROLLBACK함
  * ![](image/2022-03-29-17-42-09.png)

#### SAVEPOINT를 이용한 트랜잭션 부분 철회 
* 트랜잭션 내에서 SAVEPOINT의 지정
  * `SAVE TRAN 저장점명`
  * 트랜잭션 내에 저장점명을 다르게 하면 여러 개의 SAVEPOINT를 지정할 수 있음
* 저장점 위치로 취소
  * `ROLLBACK TRAN 저장점명`
* 하나의 트랙잭션을 이용함
1. DEPT01 테이블에서 부서번호 10번 튜플을 삭제함
2. 저장점 설정함
3. (50, ‘PRODUCT’, ‘Seoul’) 추가함
4. 저장점으로 ROLLBACK 
5. (60, DESIGN, ‘Jeju’) 추가함
   * ⇨ SAVEPOINT 에 의하여 (50, ‘PRODUCT’, ‘Seoul’)을 삽입되지 않을 것을 알 수
있음
   * ⇨ (60, ‘DESIGN’, ‘Jeju’)는 삽입되었음
* ![](image/2022-03-29-17-43-39.png)


# 강사님 공유자료
```
SQL
	- Structured Query Language
	- 구조화된 질의 언어
	- 데이터베이스관리시스템에게 명령을 전달할 때 사용되는 프로그래밍 언어
	- 종류
		DDL
			데이터 정의어
			데이터베이스 객체를 생성, 변경, 삭제할 때 사용되는 SQL
			데이터베이스 객체
				테이블 : 데이터를 저장하는 저장소
				뷰    : 가상의 테이블
				인덱스 : 검색성능 향상에 필요한 색인
			
			예시)
				* 테이블을 생성하는 DDL
				create table 테이블명 (
					컬럼명 데이터타입(크기) 제약조건,
					컬럼명 데이터타입(크기) 제약조건,
					컬럼명 데이터타입(크기) 제약조건,
					컬럼명 데이터타입(크기) 제약조건 기본값,
				);

				create table books (
					no 		number(6) 	primary key,
					title 		varchar(255) 	not null,
					author 		varchar(255),
					publisher 	varchar(255) 	not null,
					created 	date 				default sysdate
				);
				create table employee (
					id number(6) primary key,
					name varchar(100) not null,
					department varchar(100) ,
					position varchar(100) ,
				);
				
				* 테이블 삭제하기
				drop table 테이블명;
		DML
			데이터 조작어
			데이터베이스에 데이터를 추가, 변경, 삭제, 조회할 때 사용되는 SQL
			* 데이터 추가
				insert into 테이블명(컬럼명, 컬럼명, 컬럼명, ...)
				values            (값,    값,    값,    ...);
			* 데이터 변경
				update 테이블명
				set
					컬럼명 = 값,
					컬럼명 = 값;
			* 데이터 삭제
				delete from 테이블명
			* 데이터 조회
				select 컬럼명, 컬럼명, 컬럼명, ...
				from 테이블명
		DCL
			데이터베이스를 제어할 때 사용되는 SQL
			권한설정, 권한박탈, 트랜잭션처리

SQL 작성시 유의사항
	- SQL 키워드, 데이터베이스 객체명(테이블, 뷰, 인덱스), 컬럼명 전부 대소문자를 구분하지 않는다.
	- DML 작성시 사용되는 값은 대소문자를 엄격히 구분한다.

제약조건
	- 무결성제약조건
	- 테이블에 잘못된 데이터가 저장하지 않게 하는 것
	- 데이터의 저장소로 사용되는 테이블을 생성할 때 결정한다.
	예)
		학생정보
			학번은 무조건 값이 있어야 되고, 똑같은 학번을 가진 학생은 한명도 없어야 된다.
			학생이름은 무조건 값이 있어야 한다.
			학년은 1, 2, 3, 4 중에서 하나다.
			이메일은 전체 학생들의 이메일 중에서 고유해야 한다.
			성적은 0.0 ~ 4.5 사이의 값이어야 한다.
	not null 제약조건
		해당 컬럼은 null 값을 허용하지 않는다.
		not null 제약조건이 필요한 곳
			학생정보의 학생이름, 회원정보의 회원아이디, 회원정보의 회원이름, 회원정보의 비밀번호, 상품정보의 상품이름, 배송지정보의 배송주소, 결재정보의 카드번호, ...
		not null 제약조건이 필요없는 곳
			학생정보의 집전화번호, 회사원정보의 인센티브금액, 주문정보의 사용쿠폰번호, ...
	unique 제약조건
		해당 컬럼의 값은 고유해야 한다. null 값은 허용한다.
		unique 제약조건이 필요한 곳
			회원정보의 회원아이디, 회원정보의 이메일, 환자정보의 주민번호, 고객의 집전화번호, 
		unique 제약조건이 필요없는 곳
			학생정보의 학생이름, 배송지정보의 우편번호, 회원정보의 비밀번호, 회원정보의 성별, ...
	primary key 제약조건
		해당 컬럼은 무조건 값이 있어야 되고, 그 값은 고유해야 한다. 
		해당 컬럼이 그 행을 대표하는 값이고, 그 행을 다른 행과 식별하는 값이어야 하기 때문이다.
		primary key 제약조건이 필요한 곳
			학생정보의 학번, 환자정보의 환자번호, 예매정보의 예매번호, 주문정보의 주문번호, ...
			
	check 제약조건
		해당 컬럼의 값은 제시된 조건을 만족하는 값만 허용된다.
		check 제약조건이 필요한 곳
			학생정보의 학년은 1, 2, 3, 4만 가능하다.			grade number(1) check (grade in (1, 2, 3, 4))
			성별은 M, F만 가능하다.					gender char(1) check (gender in ('M', 'F'))
			가격은 0보다 크거나 같은 값만 가능하다.				price number(10) check (price >= 0)
			성적은 0 ~ 100 사이의 값이다.				score number(3) check (score >= 0 and score <= 100)
	foreign key 제약조건
		같은 테이블 혹은 다른 테이블의 특정 컬럼에 있는 값만 허용된다. null 값은 허용된다.
		foreign key 제약조건이 필요한 곳
			수강신청내역의 과목코드는 수강과목테이블의 과목코드 중 하나여야 한다.
				create table 수강신청내역 (
					과목코드 varchar(6) references 수강과목테이블(subject_no),
				)
			주문상품정보의 상품번호는 상품정보테이블의 상품번호 중 하나여야 한다. 
				create table 주문상품정보 (
					order_product_no number(5) references products (product_no)
				)


	create table products (
		product_no 		number(6) 	primary key,				
		product_name 		varchar2(255) 	not null,
		product_company_no 	number(6) 	references companies (company_no),
		product_price 		number(10) 	not null,
		product_on_sell 	char(1) 	check (product_on_sell in ('Y', 'N')) default 'Y',
		....
		constraint product_price check (product_price >= 0)
	)
		
```