# 1. Iterator, functional parameter 응용 코드 작성
## 참고 기초 이론
### Iterable
* Iterable 객체 - 반복 가능한 객체
* Iterable한 타입 - list, dict, set, str, bytes, tuple, range
* for-in문, zip(), map() 함수에서 iterable을 argument로 받는 것으로 정의되어 있다.(sequence 작업 특화)
### Iterator
* Iterator 객체 - 값을 차례대로 꺼낼 수 있는 객체
* Iterator는 Iterable한 객체를 내장함수 또는 Iterable 객체의 메소드로 객체를 생성 가능
* next() 메소드로 데이터를 순차적으로 호출하는 객체. 만약 next()로 다음 데이터를 불러 올 수 없을 경우(가장 마지막 데이터인 경우) StopIteration exception을 발생시킨다.
* iterable이라고 해서 꼭 iterator는 아니다.
* iterable을 iterator로 변환하고 싶다면, `iter()`라는 내장함수를 사용한다.
* for문으로 iterable한 객체를 looping하면 python내부에서 임시로 list를 iterator로 자동 변환하는 과정이 있다.
#### 참고 자료
https://docs.python.org/2/glossary.html#term-iterable  
https://docs.python.org/2/glossary.html#term-iteratr  
https://docs.python.org/2/library/functions.html#itr

## 1번 파이썬 예시 문제 (3)
## 1-1. a ~ b 모든 정수 더하기
```py
def solution(a, b):
    sum = 0
    for i in range(a, b):
        sum = sum + i
        
    return sum
```
## 1-2. a ~ b 모든 정수 곱하기
```py
def solution(a, b):
    mul = 1
    for i in range(a, b+1):
        mul = mul * i
        
    return mul
```
## 1-3. n개의 무작위 정수를 모두 곱하거나 더하기
```py
import random
import sys

def solution(n):
    max = sys.maxsize
    min = -sys.maxsize -1
    
    sum = 0
    mul = 1
    
    for i in range(n) :
        ran = random.randrange(min, max)
        sum = sum + ran
        mul = mul * ran
        li = [sum, mul]
    
    answer = random.choice(li)    
    return answer
```


# 2. Stack Variable(지역변수)
무엇이고 어떻게 생성되고 소멸되는지 Activation Record Instance(활성화 레코드 인스턴스)와 연관지어 설명
```
Stack Variable, 즉 지역 변수는 함수 영역에서 선언된 변수로 해당 함수에서만 사용할 수 있다.
선언과 동시에 스택 프레임이라고도 불리는 활성화 레코드에 저장된다.(운영체제가 함수를 호출하는 순간 함수의 활성화레코드가 생성된다. )
함수가 종료되면서 메모리에서 사라진다.
```
## 언어별 지역 변수
1. C언어 - 중괄호(블록)안
2. java - 메소드 안

메인 함수 역시 프로그램을 실행하기 위해 운영체제가 호출하는 일종의 지역함수
## 활성화 레코드
>https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=swryu02&logNo=220696545412

스택에 저장되는 것으로 스택 프레임이라고도 한다.
활성화 레코드는 컨텍스트 스위칭을 하기전 함수 상태를 기록하고 복원하기 위한 것으로 해당 함수의 리턴 값, 값, 파라미터, 지역 변수, 귀환 주소 등의 정보가 기록된다.
활성화 레코드는 대략 네 부분으로 나누어 볼 수 있다.  
   - 반환 값(Return Value): 피호출 함수가 호출 함수에게 반환하는 값.
   - 값 파라미터(Value Parameter): 호출 함수가 피호출 함수에게 넘기고자 하는 값. 
   - 반환 주소(Return Address): 함수가 호출된 곳의 다음 주소. 운영체제 프로그램의 번지수 200번지에 있는 명령문에서 메인함수를 불렀다면,  메인 함수 수행이 끝난 다음에는 다시 운영체제 프로그램의 바로 다음 명령문(예를 들어, 명령문 길이가 4 바이트라면 204번지)을  수행해야 하기 때문에 여기에 204를 기록한다.
   - 지역 변수(Local Variables): 함수 내에서 선언된 지역변수를 저장하는 곳.

### 메모리와 활성화 레코드
프로그램을 실행할 때 메모리는 두개의 섹션으로 나뉘는데 기계어 코드가 들어있는 코드 섹션과 데이터가 들어있는 데이터 섹션이다.

코드 섹션은 프로그램 실행을 위해 읽을 수만 있는 부분이다.
데이터 섹션은 다시 전역 메모리, 스택 메모리, 힙 메모리로 나뉘는데 프로그램 내에서 데이터가 어떻게 선언되어 있느냐에 따라 컴파일러는 이들 3개 중 한 가지 메모리를 할당하게 된다. 이 중 스택에 활성화 레코드가 생성되는데 지역변수도 이 공간에 저장된다.


# 3. C언어 함수 코드 문제
틀린 이유와 고치는 방법 설명, 활성화 레코드 인스턴스와 연관지어 동작 원리를 설명
```c
void swap(int x, int y) {
int temp = x, x = y, y = temp;
}
```
* 틀린 이유 : temp변수가 선언이 되기 전에 `y = temp`에서 temp가 사용되었으므로 활성화 레코드 인스턴스에 지역변수 temp가 없어 오류가 난다.
* 고치는 방법 : int temp = x; 로 선언 후 행을 바꿔 temp를 사용하게끔 코드를 수정한다.
    ```c
    void swap(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
    }
    ```
* 동작 원리 : C언어에서 콤마 연산자의 경우 2번째 연산을 수행해 결과값을 반환하므로 제시된 코드의 경우 temp의 선언보다 temp의 사용이 먼저 있어 ARI오류가 발생한다.

### 활성화 레코드(activation record) 구조
- 부 프로그램의 비코드 부분의 형식, 즉 배치(layout)를 활성화 레코드라 한다. 
왜냐하면 이 부분이 서술하는 데이터는 부프로그램의 활성화, 즉 부 프로그램 실행과 관련이 되기 때문이다. 활성화 레코드의 형식은 정적이다. 활성화 레코드 사례(activation record instance; ARI)는 활성화 레코드의 구체적인 예이며 활성화 레코드 형식에 존재하는 데이터의 모임이다.
 
- 단순 부프로그램의 활성화 레코드
  - 지역 변수
  - 매개 변수
  - 복귀 주소

- 단순 부프로그램은 별도의 두 부분으로 구성된다. 즉 변하지 않는 부프로그램 코드와 부프로그램이 실행되는 동안 변할 수 있는 지역 변수와 위에서 열거한 자료들이다. 단순 부프로그램의 경우 둘 다 고정 크기를 갖는다.

> https://redcarrot.tistory.com/40