>> 엘리스 프리트랙 사이트 https://kdt.elice.io/courses/15386/info

# SW 엔지니어 프리트랙 (Pre-track)
주어진 문제들을 풀어보며 알고리즘 테스트를 준비

언어 : 파이썬  
과목 개수 : 2개  
권장 학습 기간 : 4주  
수강 가능 기간 : 2021년 9월 13일 ~ 2021년 9월 30일

# TOC
- [SW 엔지니어 프리트랙 (Pre-track)](#sw-엔지니어-프리트랙-pre-track)
- [TOC](#toc)
  - [트랙 소개](#트랙-소개)
    - [✅ 프리 트랙 개요](#-프리-트랙-개요)
    - [✅ 수강 방법](#-수강-방법)
    - [📅 수강 기간](#-수강-기간)
    - [📌 역량테스트 응시 일시](#-역량테스트-응시-일시)
  - [커리큘럼](#커리큘럼)
- [풀어보며 익히는 알고리즘](#풀어보며-익히는-알고리즘)
  - [1-1. 소수의 개수 세기](#1-1-소수의-개수-세기)
    - [문제](#문제)
    - [입력](#입력)
    - [출력](#출력)
    - [시간제한](#시간제한)
    - [입력 예시](#입력-예시)
    - [출력 예시](#출력-예시)
    - [내 풀이](#내-풀이)
    - [풀이 방법](#풀이-방법)
    - [피드백](#피드백)
  - [1-2. 거스름돈 1](#1-2-거스름돈-1)
    - [문제](#문제-1)
    - [입력](#입력-1)
    - [출력](#출력-1)
    - [입력 예시](#입력-예시-1)
    - [출력 예시](#출력-예시-1)
    - [내 풀이](#내-풀이-1)
    - [풀이 방법](#풀이-방법-1)
    - [피드백](#피드백-1)
  - [1-3. 골드바흐의 추측](#1-3-골드바흐의-추측)
    - [문제](#문제-2)
    - [입력](#입력-2)
    - [출력](#출력-2)
    - [시간제한](#시간제한-1)
    - [입력 예시](#입력-예시-2)
    - [출력 예시](#출력-예시-2)
    - [부분점수](#부분점수)
    - [내 풀이](#내-풀이-2)
    - [풀이방법](#풀이방법)
    - [피드백](#피드백-2)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>



## 트랙 소개
### ✅ 프리 트랙 개요
* 학습 목적 : 프리 트랙은 본격적인 엘리스 SW 엔지니어 트랙을 시작하기에 앞서 프로그래밍적 역량을 자가진단해 보고, 알고리즘 테스트를 준비하기 위한 사전 학습 과정입니다.
* 학습 대상 : 엘리스 SW 엔지니어 트랙 모집 서류 통과자 분들을 대상으로 합니다.
### ✅ 수강 방법
1. 서류 지원 시 입력하신 이메일을 통해 안내된 수강 비밀번호를 입력하여 수강신청하세요.
2. 프리트랙에 포함된 두 과목 “풀어보며 익히는 알고리즘”과 “기출문제 모음집”을 학습하세요.
### 📅 수강 기간
* 2021년 9월 30일까지 학습하실 수 있습니다.

### 📌 역량테스트 응시 일시
* 2021년 10월 1~2일 양일 중 자유 시간대에 1회 응시 가능

## 커리큘럼
1. 풀어보며 익히는 알고리즘
2. 기출문제 모음집

# 풀어보며 익히는 알고리즘

## 1-1. 소수의 개수 세기
### 문제
약수는 어떤 수를 나누어떨어지게 하는 수를 의미합니다.

예를 들어 4는 16의 약수입니다. 16÷4=416 \div 4 = 416÷4=4이기 때문입니다.

하지만 3은 16의 약수가 아닙니다. 16÷3=5⋅⋅⋅116 \div 3 = 5 \cdot\cdot\cdot 116÷3=5⋅⋅⋅1으로 1이 남기 때문입니다.

소수(prime number)는 약수가 2개인 수를 의미합니다.

예를 들어 2, 3, 5와 같은 수는 약수가 1과 자기 자신밖에 없으므로 소수입니다.

어떤 수 nnn이 입력되면, 1~$n$사이의 소수가 몇 개인지 세어서 출력하는 프로그램을 작성해 봅시다.

### 입력
어떤 수 nnn이 입력됩니다. 해당 수는 10,000 이하의 자연수입니다.

### 출력
1 ~ nnn인 수중에서 소수인 수의 개수를 출력합니다.

### 시간제한
* 채점 중에는 제출된 프로그램을 다양한 입력값으로 여러 번 실행하면서 반복적으로 검사합니다.
* 이 문제에서는 제출된 프로그램을 1회 실행하는데 1초가 주어집니다.
* 만약 그 시간을 넘길 경우 오답 처리됩니다. 시간제한을 넘기지 않도록 효율적으로 작성해야겠지요?
### 입력 예시
```
10
```
### 출력 예시
```
4
```
* 1~10중 소수는 2, 3, 5, 7로 총 4개가 있습니다.
* 부분점수
* 1 ≤ n < 500 : 30점
* 500 ≤ n ≤ 10,000 : 70점

### 내 풀이
```py
# 입력
n = int(input())

# 방법1(30점) - 약수의 개수
# 소수를 담을 리스트 선언
plist = []
# 약수의 개수를 구해 소수리스트 구하기
for i in range(1, n + 1):
    cnt = 0
    for j in range(2, i+1):
        if i % j == 0:
            cnt += 1
    if cnt == 1:
        plist.append(i)
# 출력
print(len(plist))

# 방법2(70점) - 에라토스테네스의 체
# 블리언 리스트 생성 및 True로 초기화
plist = [True] * n

# 0, 1은 소수가 아니므로 False
plist[0] = False
plist[1] = False

# n의 최대 약수가 루트 n 이하이므로 int(루트n)까지 검사
m = int(n**0.5)
for i in range(1, m+1):
    if plist[i] == True:
        for j in range(i+i, n, i):
            plist[j] = False;

# 소수 개수 구하기
cnt = 0
for i in range(1, n):
    if plist[i] == True:
        cnt += 1
# 출력
print(cnt)
```
### 풀이 방법
* 약수의 개수를 이용해 풀었다. (부분점수 30점)
  1. 소수를 담을 리스트를 선언하였다.
  2. 중첩 for 문을 이용해 1부터 n까지 약수의 개수를 구했다.
  3. 약수의 개수가 1이면 소수리스트에 추가하였다.
  4. 리스트의 길이를 출력하여 소수의 개수를 구하였다.
* 에라토스테네스의 체를 이용하여 풀었다. (부분점수 70점)
  1. 입력받은 n값으로 블리언 리스트를 만들고 True로 초기화 하였다. (True는 소수를 의미)
  2. 0, 1은 소수가 아니므로 리스트의 0, 1번째 인덱스를 False로 선언하였다.
  3. n의 최대 약수가 루트 n 이하이므로 검사 범위를 int(루트n)으로 정하여 검사하였다.
  4. 소수의 개수를 cnt라는 변수에 저장하고 1부터 n까지 블리언 리스트 plist를 검사하여 카운트하고 출력하였다.
### 피드백
* 자바로 풀었던 것보다 코드의 양이 적고 조금 더 간단하지만 파이썬에 익숙하지 않아 애를 먹었다.
* 특히 루트 내장 함수 sqrt()를 몰랐고 ** 연산자(제곱연산자)를 새롭게 알게 되었다.
* 약수의 개수를 이용해 푸는 방법을 새롭게 알게 되었다.
* range()함수의 3번째 파라미터가 의미하는 것을 알게 되었다.
  * range(start, end, step) - step은 간격을 의미한다. start부터 end까지의 범위를 step의 간격을 둔다는 의미.
  * 예를들어 range(1, 10, 2)는 1부터 10까지 2의 간격을 둔다
      ```py
      for i in range(1,10,2):
          print(i)

      <!-- 결과 -->
      1
      3
      5
      7
      9
      ```

## 1-2. 거스름돈 1
### 문제
편의점 알바를 시작한 엘리스는 물건을 산 손님에게 알맞은 거스름돈을 주어야 합니다.

여기서 중요한 것은 손님이 불편하지 않게 동전을 최대한 적게 주어야 합니다.

편의점의 금고에는 10원, 50원, 100원, 500원 동전이 있습니다.

거스름돈을 주려면 몇 개의 동전이 필요한지 출력하는 프로그램을 작성해 봅시다.


### 입력
첫째 줄에 거스름돈이 입력됩니다.

거스름돈은 반드시 주어진 동전을 이용해 줄 수 있도록 주어집니다.

거스름돈은 최대 10,000원입니다.

### 출력
필요한 동전의 개수를 출력합니다.
시간제한
각 실행 케이스마다 0.5초의 시간이 주어집니다.

### 입력 예시
```
760
```
### 출력 예시
```
5
```

### 내 풀이
```py
# 거스름돈의 개수 구하기 
# 입력
change = int(input())
# 거스름돈의 종류 리스트
coin = [500, 100, 50, 10]
# 거스름돈 개수 세서 출력
cnt = 0
for c in coin:
    while change >= c:
        change = change - c
        cnt += 1
        
print(cnt)
```
### 풀이 방법
  1. 거스름돈의 종류 리스트를 만든다
  2. 거스름돈의 종류를 큰 단위부터 반복해 change(총 거슬러줘야하는 거스름돈)과 비교하며 더 작거나 같으면 그만큼 빼고 카운트한다.
  3. cnt를 출력하면 총 동전의 개수를 알 수 있다.
### 피드백
  * 반복문에는 while문도 있다.


## 1-3. 골드바흐의 추측
### 문제
골드바흐의 추측이란 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다는 추측입니다.

예를 들어 4, 6, 8은 다음과 같이 나타낼 수 있습니다.

4 = 2 + 2

6 = 3 + 3

8 = 3 + 5

현재 이 추측은 참인지 거짓인지 아직 증명되지 않았으나 충분히 크지 않은 수에 대해서는 컴퓨터를 통해 참으로 결론을 내린 상태입니다.

여러분도 한번 짝수를 두 소수의 합으로 나타내어 봅시다!


### 입력
N개의 짝수가 공백으로 구분되어 입력됩니다.

각 짝수는 모두 최대 10,000을 넘지 않습니다.

### 출력
줄마다 합계가 짝수가 되는 두 소수를 작은 소수부터 차례대로 출력합니다.

만약 해당 짝수를 만드는 소수의 쌍이 여러 개라면 가장 두 소수의 차이가 적은 것을 출력합니다.

### 시간제한
각 실행 케이스마다 1.5초의 시간이 주어집니다.

### 입력 예시
```
4 6 8
```

### 출력 예시
```
2 2
3 3
3 5
```

### 부분점수
* 1 ≤ N ≤ 5 : 30점
* 5 < N ≤ 500 : 70점

### 내 풀이
```py
```
### 풀이방법
### 피드백